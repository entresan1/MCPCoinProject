"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile";
exports.ids = ["vendor-chunks/@solana-mobile"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startRemoteScenario: () => (/* binding */ startRemoteScenario),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   transactRemote: () => (/* binding */ transactRemote)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getPayloadFromTransaction(transaction) {\n    const serializedTransaction = \"version\" in transaction ? transaction.serialize() : transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n    });\n    const payload = fromUint8Array(serializedTransaction);\n    return payload;\n}\nfunction getTransactionFromWireMessage(byteArray) {\n    const numSignatures = byteArray[0];\n    const messageOffset = numSignatures * _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES + 1;\n    const version = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n    if (version === \"legacy\") {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(byteArray);\n    } else {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(byteArray);\n    }\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const augmentedCallback = (wallet)=>{\n            return callback(augmentWalletAPI(wallet));\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transact)(augmentedCallback, config);\n    });\n}\nfunction transactRemote(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const augmentedCallback = (wallet)=>{\n            const augmentedAPI = new Proxy({}, {\n                get (target, p) {\n                    if (target[p] == null) {\n                        switch(p){\n                            case \"signAndSendTransactions\":\n                                target[p] = function(_a) {\n                                    var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\n                                        \"minContextSlot\",\n                                        \"commitment\",\n                                        \"skipPreflight\",\n                                        \"maxRetries\",\n                                        \"waitForCommitmentToSendNextTransaction\",\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const options = {\n                                            min_context_slot: minContextSlot,\n                                            commitment: commitment,\n                                            skip_preflight: skipPreflight,\n                                            max_retries: maxRetries,\n                                            wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                        };\n                                        const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element)=>element != null) ? {\n                                            options: options\n                                        } : null), {\n                                            payloads\n                                        }));\n                                        const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                        return signatures;\n                                    });\n                                };\n                                break;\n                            case \"signMessages\":\n                                target[p] = function(_a) {\n                                    var { payloads } = _a, rest = __rest(_a, [\n                                        \"payloads\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                        const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), {\n                                            payloads: base64EncodedPayloads\n                                        }));\n                                        const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                        return signedMessages;\n                                    });\n                                };\n                                break;\n                            case \"signTransactions\":\n                                target[p] = function(_a) {\n                                    var { transactions } = _a, rest = __rest(_a, [\n                                        \"transactions\"\n                                    ]);\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), {\n                                            payloads\n                                        }));\n                                        const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                        const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                        return signedTransactions;\n                                    });\n                                };\n                                break;\n                            default:\n                                {\n                                    target[p] = wallet[p];\n                                    break;\n                                }\n                        }\n                    }\n                    return target[p];\n                },\n                defineProperty () {\n                    return false;\n                },\n                deleteProperty () {\n                    return false;\n                }\n            });\n            return callback(augmentedAPI);\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transactRemote)(augmentedCallback, config);\n    });\n}\nfunction startRemoteScenario(config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { wallet, close, associationUrl } = yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.startRemoteScenario)(config);\n        const augmentedPromise = wallet.then((wallet)=>{\n            return augmentWalletAPI(wallet);\n        });\n        return {\n            wallet: augmentedPromise,\n            close,\n            associationUrl\n        };\n    });\n}\nfunction augmentWalletAPI(wallet) {\n    return new Proxy({}, {\n        get (target, p) {\n            if (target[p] == null) {\n                switch(p){\n                    case \"signAndSendTransactions\":\n                        target[p] = function(_a) {\n                            var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\n                                \"minContextSlot\",\n                                \"commitment\",\n                                \"skipPreflight\",\n                                \"maxRetries\",\n                                \"waitForCommitmentToSendNextTransaction\",\n                                \"transactions\"\n                            ]);\n                            return __awaiter(this, void 0, void 0, function*() {\n                                const payloads = transactions.map(getPayloadFromTransaction);\n                                const options = {\n                                    min_context_slot: minContextSlot,\n                                    commitment: commitment,\n                                    skip_preflight: skipPreflight,\n                                    max_retries: maxRetries,\n                                    wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                };\n                                const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), Object.values(options).some((element)=>element != null) ? {\n                                    options: options\n                                } : null), {\n                                    payloads\n                                }));\n                                const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                return signatures;\n                            });\n                        };\n                        break;\n                    case \"signMessages\":\n                        target[p] = function(_a) {\n                            var { payloads } = _a, rest = __rest(_a, [\n                                \"payloads\"\n                            ]);\n                            return __awaiter(this, void 0, void 0, function*() {\n                                const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), {\n                                    payloads: base64EncodedPayloads\n                                }));\n                                const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                return signedMessages;\n                            });\n                        };\n                        break;\n                    case \"signTransactions\":\n                        target[p] = function(_a) {\n                            var { transactions } = _a, rest = __rest(_a, [\n                                \"transactions\"\n                            ]);\n                            return __awaiter(this, void 0, void 0, function*() {\n                                const payloads = transactions.map(getPayloadFromTransaction);\n                                const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), {\n                                    payloads\n                                }));\n                                const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                return signedTransactions;\n                            });\n                        };\n                        break;\n                    default:\n                        {\n                            target[p] = wallet[p];\n                            break;\n                        }\n                }\n            }\n            return target[p];\n        },\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpSDtBQUN3RDtBQUNqSjtBQUV4Qjs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU1csT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUVBLFNBQVNXLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFB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QUFPO29DQUFFQztnQ0FBUztnQ0FDL0ksTUFBTXFCLHVCQUF1QkYsa0NBQWtDdEQsR0FBRyxDQUFDTDtnQ0FDbkUsTUFBTThELHFCQUFxQkQscUJBQXFCeEQsR0FBRyxDQUFDVTtnQ0FDcEQsT0FBTytDOzRCQUNYO3dCQUNKO3dCQUNBO29CQUNKO3dCQUFTOzRCQUNML0IsTUFBTSxDQUFDakUsRUFBRSxHQUFHNEQsTUFBTSxDQUFDNUQsRUFBRTs0QkFDckI7d0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLE9BQU9pRSxNQUFNLENBQUNqRSxFQUFFO1FBQ3BCO1FBQ0FpRztZQUNJLE9BQU87UUFDWDtRQUNBQztZQUNJLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFFeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tY3AtY29pbi8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wtd2ViM2pzL2xpYi9lc20vaW5kZXguanM/MGI2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZXJzaW9uZWRNZXNzYWdlLCBUcmFuc2FjdGlvbiwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgdHJhbnNhY3QgYXMgdHJhbnNhY3QkMSwgdHJhbnNhY3RSZW1vdGUgYXMgdHJhbnNhY3RSZW1vdGUkMSwgc3RhcnRSZW1vdGVTY2VuYXJpbyBhcyBzdGFydFJlbW90ZVNjZW5hcmlvJDEgfSBmcm9tICdAc29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGZyb21VaW50OEFycmF5KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiB3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmNhbGwobnVsbCwgLi4uYnl0ZUFycmF5KSk7XG59XG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3aW5kb3dcbiAgICAgICAgLmF0b2IoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSlcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9ICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvblxuICAgICAgICA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gICAgICAgIDogdHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYXlsb2FkID0gZnJvbVVpbnQ4QXJyYXkoc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uRnJvbVdpcmVNZXNzYWdlKGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IG51bVNpZ25hdHVyZXMgPSBieXRlQXJyYXlbMF07XG4gICAgY29uc3QgbWVzc2FnZU9mZnNldCA9IG51bVNpZ25hdHVyZXMgKiBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTICsgMTtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKGJ5dGVBcnJheS5zbGljZShtZXNzYWdlT2Zmc2V0LCBieXRlQXJyYXkubGVuZ3RoKSk7XG4gICAgaWYgKHZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKGJ5dGVBcnJheSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gVmVyc2lvbmVkVHJhbnNhY3Rpb24uZGVzZXJpYWxpemUoYnl0ZUFycmF5KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2FjdChjYWxsYmFjaywgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXVnbWVudGVkQ2FsbGJhY2sgPSAod2FsbGV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYXVnbWVudFdhbGxldEFQSSh3YWxsZXQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRyYW5zYWN0JDEoYXVnbWVudGVkQ2FsbGJhY2ssIGNvbmZpZyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2FjdFJlbW90ZShjYWxsYmFjaywgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXVnbWVudGVkQ2FsbGJhY2sgPSAod2FsbGV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWdtZW50ZWRBUEkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IG1pbkNvbnRleHRTbG90LCBjb21taXRtZW50LCBza2lwUHJlZmxpZ2h0LCBtYXhSZXRyaWVzLCB3YWl0Rm9yQ29tbWl0bWVudFRvU2VuZE5leHRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25zIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wibWluQ29udGV4dFNsb3RcIiwgXCJjb21taXRtZW50XCIsIFwic2tpcFByZWZsaWdodFwiLCBcIm1heFJldHJpZXNcIiwgXCJ3YWl0Rm9yQ29tbWl0bWVudFRvU2VuZE5leHRUcmFuc2FjdGlvblwiLCBcInRyYW5zYWN0aW9uc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdHJhbnNhY3Rpb25zLm1hcChnZXRQYXlsb2FkRnJvbVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5fY29udGV4dF9zbG90OiBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9wcmVmbGlnaHQ6IHNraXBQcmVmbGlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9yZXRyaWVzOiBtYXhSZXRyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0X2Zvcl9jb21taXRtZW50X3RvX3NlbmRfbmV4dF90cmFuc2FjdGlvbjogd2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlczogYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIChPYmplY3QudmFsdWVzKG9wdGlvbnMpLnNvbWUoZWxlbWVudCA9PiBlbGVtZW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBvcHRpb25zOiBvcHRpb25zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksIHsgcGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBiYXNlNjRFbmNvZGVkU2lnbmF0dXJlcy5tYXAodG9VaW50OEFycmF5KS5tYXAoYnM1OC5lbmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25NZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgcGF5bG9hZHMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJwYXlsb2Fkc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRQYXlsb2FkcyA9IHBheWxvYWRzLm1hcChmcm9tVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZWRfcGF5bG9hZHM6IGJhc2U2NEVuY29kZWRTaWduZWRNZXNzYWdlcyB9ID0geWllbGQgd2FsbGV0LnNpZ25NZXNzYWdlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IHBheWxvYWRzOiBiYXNlNjRFbmNvZGVkUGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VzID0gYmFzZTY0RW5jb2RlZFNpZ25lZE1lc3NhZ2VzLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRNZXNzYWdlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyB0cmFuc2FjdGlvbnMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZWRfcGF5bG9hZHM6IGJhc2U2NEVuY29kZWRDb21waWxlZFRyYW5zYWN0aW9ucyB9ID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkcyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGlsZWRUcmFuc2FjdGlvbnMgPSBiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gY29tcGlsZWRUcmFuc2FjdGlvbnMubWFwKGdldFRyYW5zYWN0aW9uRnJvbVdpcmVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gd2FsbGV0W3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhdWdtZW50ZWRBUEkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geWllbGQgdHJhbnNhY3RSZW1vdGUkMShhdWdtZW50ZWRDYWxsYmFjaywgY29uZmlnKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0UmVtb3RlU2NlbmFyaW8oY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyB3YWxsZXQsIGNsb3NlLCBhc3NvY2lhdGlvblVybCB9ID0geWllbGQgc3RhcnRSZW1vdGVTY2VuYXJpbyQxKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGF1Z21lbnRlZFByb21pc2UgPSB3YWxsZXQudGhlbigod2FsbGV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXVnbWVudFdhbGxldEFQSSh3YWxsZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgd2FsbGV0OiBhdWdtZW50ZWRQcm9taXNlLCBjbG9zZSwgYXNzb2NpYXRpb25VcmwgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGF1Z21lbnRXYWxsZXRBUEkod2FsbGV0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgbWluQ29udGV4dFNsb3QsIGNvbW1pdG1lbnQsIHNraXBQcmVmbGlnaHQsIG1heFJldHJpZXMsIHdhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbnMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJtaW5Db250ZXh0U2xvdFwiLCBcImNvbW1pdG1lbnRcIiwgXCJza2lwUHJlZmxpZ2h0XCIsIFwibWF4UmV0cmllc1wiLCBcIndhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uXCIsIFwidHJhbnNhY3Rpb25zXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5fY29udGV4dF9zbG90OiBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3ByZWZsaWdodDogc2tpcFByZWZsaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heF9yZXRyaWVzOiBtYXhSZXRyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb246IHdhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlczogYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIChPYmplY3QudmFsdWVzKG9wdGlvbnMpLnNvbWUoZWxlbWVudCA9PiBlbGVtZW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3B0aW9uczogb3B0aW9ucyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpKSwgeyBwYXlsb2FkcyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBiYXNlNjRFbmNvZGVkU2lnbmF0dXJlcy5tYXAodG9VaW50OEFycmF5KS5tYXAoYnM1OC5lbmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbk1lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHBheWxvYWRzIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wicGF5bG9hZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRQYXlsb2FkcyA9IHBheWxvYWRzLm1hcChmcm9tVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkczogYmFzZTY0RW5jb2RlZFBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZXMgPSBiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMubWFwKHRvVWludDhBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRNZXNzYWdlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnblRyYW5zYWN0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyB0cmFuc2FjdGlvbnMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdHJhbnNhY3Rpb25zLm1hcChnZXRQYXlsb2FkRnJvbVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZWRfcGF5bG9hZHM6IGJhc2U2NEVuY29kZWRDb21waWxlZFRyYW5zYWN0aW9ucyB9ID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkcyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkVHJhbnNhY3Rpb25zID0gYmFzZTY0RW5jb2RlZENvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBjb21waWxlZFRyYW5zYWN0aW9ucy5tYXAoZ2V0VHJhbnNhY3Rpb25Gcm9tV2lyZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSB3YWxsZXRbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgc3RhcnRSZW1vdGVTY2VuYXJpbywgdHJhbnNhY3QsIHRyYW5zYWN0UmVtb3RlIH07XG4iXSwibmFtZXMiOlsiVmVyc2lvbmVkTWVzc2FnZSIsIlRyYW5zYWN0aW9uIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwidHJhbnNhY3QiLCJ0cmFuc2FjdCQxIiwidHJhbnNhY3RSZW1vdGUiLCJ0cmFuc2FjdFJlbW90ZSQxIiwic3RhcnRSZW1vdGVTY2VuYXJpbyIsInN0YXJ0UmVtb3RlU2NlbmFyaW8kMSIsImJzNTgiLCJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZnJvbVVpbnQ4QXJyYXkiLCJieXRlQXJyYXkiLCJ3aW5kb3ciLCJidG9hIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidG9VaW50OEFycmF5IiwiYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSIsIlVpbnQ4QXJyYXkiLCJhdG9iIiwic3BsaXQiLCJtYXAiLCJjIiwiY2hhckNvZGVBdCIsImdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwidmVyaWZ5U2lnbmF0dXJlcyIsInBheWxvYWQiLCJnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZSIsIm51bVNpZ25hdHVyZXMiLCJtZXNzYWdlT2Zmc2V0IiwidmVyc2lvbiIsImRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24iLCJzbGljZSIsImZyb20iLCJkZXNlcmlhbGl6ZSIsImNhbGxiYWNrIiwiY29uZmlnIiwiYXVnbWVudGVkQ2FsbGJhY2siLCJ3YWxsZXQiLCJhdWdtZW50V2FsbGV0QVBJIiwiYXVnbWVudGVkQVBJIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJfYSIsIm1pbkNvbnRleHRTbG90IiwiY29tbWl0bWVudCIsInNraXBQcmVmbGlnaHQiLCJtYXhSZXRyaWVzIiwid2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnMiLCJyZXN0IiwicGF5bG9hZHMiLCJvcHRpb25zIiwibWluX2NvbnRleHRfc2xvdCIsInNraXBfcHJlZmxpZ2h0IiwibWF4X3JldHJpZXMiLCJ3YWl0X2Zvcl9jb21taXRtZW50X3RvX3NlbmRfbmV4dF90cmFuc2FjdGlvbiIsInNpZ25hdHVyZXMiLCJiYXNlNjRFbmNvZGVkU2lnbmF0dXJlcyIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zIiwiYXNzaWduIiwidmFsdWVzIiwic29tZSIsImVsZW1lbnQiLCJlbmNvZGUiLCJiYXNlNjRFbmNvZGVkUGF5bG9hZHMiLCJzaWduZWRfcGF5bG9hZHMiLCJiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMiLCJzaWduTWVzc2FnZXMiLCJzaWduZWRNZXNzYWdlcyIsImJhc2U2NEVuY29kZWRDb21waWxlZFRyYW5zYWN0aW9ucyIsInNpZ25UcmFuc2FjdGlvbnMiLCJjb21waWxlZFRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsImRlZmluZVByb3BlcnR5IiwiZGVsZXRlUHJvcGVydHkiLCJjbG9zZSIsImFzc29jaWF0aW9uVXJsIiwiYXVnbWVudGVkUHJvbWlzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   startRemoteScenario: () => (/* binding */ startRemoteScenario),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   transactRemote: () => (/* binding */ transactRemote)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: \"ERROR_ASSOCIATION_PORT_OUT_OF_RANGE\",\n    ERROR_REFLECTOR_ID_OUT_OF_RANGE: \"ERROR_REFLECTOR_ID_OUT_OF_RANGE\",\n    ERROR_FORBIDDEN_WALLET_BASE_URL: \"ERROR_FORBIDDEN_WALLET_BASE_URL\",\n    ERROR_SECURE_CONTEXT_REQUIRED: \"ERROR_SECURE_CONTEXT_REQUIRED\",\n    ERROR_SESSION_CLOSED: \"ERROR_SESSION_CLOSED\",\n    ERROR_SESSION_TIMEOUT: \"ERROR_SESSION_TIMEOUT\",\n    ERROR_WALLET_NOT_FOUND: \"ERROR_WALLET_NOT_FOUND\",\n    ERROR_INVALID_PROTOCOL_VERSION: \"ERROR_INVALID_PROTOCOL_VERSION\",\n    ERROR_BROWSER_NOT_SUPPORTED: \"ERROR_BROWSER_NOT_SUPPORTED\"\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args){\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaMobileWalletAdapterError\";\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args){\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = \"SolanaMobileWalletAdapterProtocolError\";\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction fromUint8Array(byteArray, urlsafe) {\n    const base64 = window.btoa(String.fromCharCode.call(null, ...byteArray));\n    if (urlsafe) {\n        return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } else return base64;\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const publicKeyBuffer = yield crypto.subtle.exportKey(\"raw\", ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({\n            hash: \"SHA-256\",\n            name: \"ECDSA\"\n        }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64(payload) {\n    return encode(createSIWSMessage(payload));\n}\n// optional features\nconst SolanaSignTransactions = \"solana:signTransactions\";\nconst SolanaCloneAuthorization = \"solana:cloneAuthorization\";\nconst SolanaSignInWithSolana = \"solana:signInWithSolana\";\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */ function createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get (target, p) {\n            // Wrapping a Proxy in a promise results in the Proxy being asked for a 'then' property so must \n            // return null if 'then' is called on this proxy to let the 'resolve()' call know this is not a promise.\n            // see: https://stackoverflow.com/a/53890904\n            //@ts-ignore\n            if (p === \"then\") {\n                return null;\n            }\n            if (target[p] == null) {\n                target[p] = function(inputParams) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === \"authorize\" && params.sign_in_payload && !result.sign_in_result) {\n                            result[\"sign_in_result\"] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        }\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */ function handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName.toString().replace(/[A-Z]/g, (letter)=>`_${letter.toLowerCase()}`).toLowerCase();\n    switch(methodName){\n        case \"authorize\":\n            {\n                let { chain } = params;\n                if (protocolVersion === \"legacy\") {\n                    switch(chain){\n                        case \"solana:testnet\":\n                            {\n                                chain = \"testnet\";\n                                break;\n                            }\n                        case \"solana:devnet\":\n                            {\n                                chain = \"devnet\";\n                                break;\n                            }\n                        case \"solana:mainnet\":\n                            {\n                                chain = \"mainnet-beta\";\n                                break;\n                            }\n                        default:\n                            {\n                                chain = params.cluster;\n                            }\n                    }\n                    params.cluster = chain;\n                } else {\n                    switch(chain){\n                        case \"testnet\":\n                        case \"devnet\":\n                            {\n                                chain = `solana:${chain}`;\n                                break;\n                            }\n                        case \"mainnet-beta\":\n                            {\n                                chain = \"solana:mainnet\";\n                                break;\n                            }\n                    }\n                    params.chain = chain;\n                }\n            }\n        case \"reauthorize\":\n            {\n                const { auth_token, identity } = params;\n                if (auth_token) {\n                    switch(protocolVersion){\n                        case \"legacy\":\n                            {\n                                method = \"reauthorize\";\n                                params = {\n                                    auth_token: auth_token,\n                                    identity: identity\n                                };\n                                break;\n                            }\n                        default:\n                            {\n                                method = \"authorize\";\n                                break;\n                            }\n                    }\n                }\n                break;\n            }\n    }\n    return {\n        method,\n        params\n    };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */ function handleMobileWalletResponse(method, response, protocolVersion) {\n    switch(method){\n        case \"getCapabilities\":\n            {\n                const capabilities = response;\n                switch(protocolVersion){\n                    case \"legacy\":\n                        {\n                            const features = [\n                                SolanaSignTransactions\n                            ];\n                            if (capabilities.supports_clone_authorization === true) {\n                                features.push(SolanaCloneAuthorization);\n                            }\n                            return Object.assign(Object.assign({}, capabilities), {\n                                features: features\n                            });\n                        }\n                    case \"v1\":\n                        {\n                            return Object.assign(Object.assign({}, capabilities), {\n                                supports_sign_and_send_transactions: true,\n                                supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization)\n                            });\n                        }\n                }\n            }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function*() {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), {\n            domain,\n            address\n        }));\n        const signMessageResult = yield protocolRequestHandler(\"sign_messages\", {\n            addresses: [\n                address\n            ],\n            payloads: [\n                siwsMessage\n            ]\n        });\n        const signInResult = {\n            address: address,\n            signed_message: siwsMessage,\n            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)\n        };\n        return signInResult;\n    });\n}\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error(\"Outbound sequence number overflow. The maximum sequence number is 32-bytes.\");\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: \"AES-GCM\",\n        tagLength: 128\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder(\"utf-8\");\n    }\n    return _utf8Decoder;\n}\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDSA\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"sign\"\n        ]);\n    });\n}\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function*() {\n        return yield crypto.subtle.generateKey({\n            name: \"ECDH\",\n            namedCurve: \"P-256\"\n        }, false, [\n            \"deriveKey\",\n            \"deriveBits\"\n        ]);\n    });\n}\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = \"\";\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for(let ii = 0; ii < len; ii++){\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, {\n            port\n        });\n    }\n    return port;\n}\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m)=>({\n            \"/\": \"_\",\n            \"+\": \"-\",\n            \"=\": \".\"\n        })[m]);\n}\nconst INTENT_NAME = \"solana-wallet\";\nfunction getPathParts(pathString) {\n    return pathString// Strip leading and trailing slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")// Return an array of directories\n    .split(\"/\");\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        } catch (_a) {} // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== \"https:\") {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith(\"/\") ? methodPathname : [\n        ...getPathParts(baseUrl.pathname),\n        ...getPathParts(methodPathname)\n    ].join(\"/\");\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = [\n    \"v1\"\n]) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey(\"raw\", associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL(\"v1/associate/local\", associationURLBase);\n        url.searchParams.set(\"association\", getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set(\"port\", `${associationPort}`);\n        protocolVersions.forEach((version)=>{\n            url.searchParams.set(\"v\", version);\n        });\n        return url;\n    });\n}\nfunction getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, reflectorId, associationURLBase, protocolVersions = [\n    \"v1\"\n]) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const exportedKey = yield crypto.subtle.exportKey(\"raw\", associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL(\"v1/associate/remote\", associationURLBase);\n        url.searchParams.set(\"association\", getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set(\"reflector\", `${hostAuthority}`);\n        url.searchParams.set(\"id\", `${fromUint8Array(reflectorId, true)}`);\n        protocolVersions.forEach((version)=>{\n            url.searchParams.set(\"v\", version);\n        });\n        return url;\n    });\n}\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, \"error\")) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\nfunction parseHelloRsp(payloadBuffer, associationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey(\"raw\", associationPublicKey),\n            crypto.subtle.importKey(\"raw\", payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), {\n                name: \"ECDH\",\n                namedCurve: \"P-256\"\n            }, false, [])\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({\n            name: \"ECDH\",\n            public: walletPublicKey\n        }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey(\"raw\", sharedSecret, \"HKDF\", false, [\n            \"deriveKey\"\n        ]);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array()\n        }, ecdhSecretKey, {\n            name: \"AES-GCM\",\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return aesKeyMaterialVal;\n    });\n}\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = \"legacy\";\n        if (Object.hasOwnProperty.call(jsonProperties, \"v\")) {\n            switch(jsonProperties.v){\n                case 1:\n                case \"1\":\n                case \"v1\":\n                    protocolVersion = \"v1\";\n                    break;\n                case \"legacy\":\n                    protocolVersion = \"legacy\";\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return {\n            protocol_version: protocolVersion\n        };\n    });\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf(\"Firefox/\") !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject)=>{\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener(\"blur\", handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener(\"blur\", handleBlur);\n        const timeoutId = setTimeout(()=>{\n            cleanup();\n            reject();\n        }, 3000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement(\"iframe\");\n        _frame.style.display = \"none\";\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction launchAssociation(associationUrl) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (associationUrl.protocol === \"https:\") {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        } else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch(browser){\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        break;\n                    case Browser.Other:\n                        {\n                            const detectionPromise = getDetectionPromise();\n                            window.location.assign(associationUrl);\n                            yield detectionPromise;\n                            break;\n                        }\n                    default:\n                        assertUnreachable(browser);\n                }\n            } catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, \"Found no installed wallet that supports the mobile wallet protocol.\");\n            }\n        }\n    });\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        yield launchAssociation(associationUrl);\n        return randomAssociationPort;\n    });\n}\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */ retryDelayScheduleMs: [\n        150,\n        150,\n        200,\n        500,\n        500,\n        750,\n        750,\n        1000\n    ],\n    timeoutMs: 30000\n};\nconst WEBSOCKET_PROTOCOL_BINARY = \"com.solana.mobilewalletadapter.v1\";\nconst WEBSOCKET_PROTOCOL_BASE64 = \"com.solana.mobilewalletadapter.v1.base64\";\nfunction assertSecureContext() {\n    if (true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, \"The mobile wallet adapter protocol must be used in a secure context (`https`).\");\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    } catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Invalid base URL supplied by wallet\");\n    }\n    if (url.protocol !== \"https:\") {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, \"Base URLs supplied by wallets must be valid `https` URLs\");\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction decodeVarLong(byteArray) {\n    var bytes = new Uint8Array(byteArray), l = byteArray.byteLength, limit = 10, value = 0, offset = 0, b;\n    do {\n        if (offset >= l || offset > limit) throw new RangeError(\"Failed to decode varint\");\n        b = bytes[offset++];\n        value |= (b & 0x7F) << 7 * offset;\n    }while (b >= 0x80);\n    return {\n        value,\n        offset\n    };\n}\nfunction getReflectorIdFromByteArray(byteArray) {\n    let { value: length, offset } = decodeVarLong(byteArray);\n    return new Uint8Array(byteArray.slice(offset, offset + length));\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (()=>{\n            const schedule = [\n                ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs\n            ];\n            return ()=>schedule.length > 1 ? schedule.shift() : schedule[0];\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = {\n            __type: \"disconnected\"\n        };\n        return new Promise((resolve, reject)=>{\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = ()=>__awaiter(this, void 0, void 0, function*() {\n                    if (state.__type !== \"connecting\") {\n                        console.warn(\"Expected adapter state to be `connecting` at the moment the websocket opens. \" + `Got \\`${state.__type}\\`.`);\n                        return;\n                    }\n                    socket.removeEventListener(\"open\", handleOpen);\n                    // previous versions of this library and walletlib incorrectly implemented the MWA session \n                    // establishment protocol for local connections. The dapp is supposed to wait for the \n                    // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ \n                    // immediately upon connection to the websocket server regardless of wether or not an \n                    // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior \n                    // in case the user is using a wallet that has not updated their walletlib implementation. \n                    const { associationKeypair } = state;\n                    const ecdhKeypair = yield generateECDHKeypair();\n                    socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                    state = {\n                        __type: \"hello_req_sent\",\n                        associationPublicKey: associationKeypair.publicKey,\n                        ecdhPrivateKey: ecdhKeypair.privateKey\n                    };\n                });\n            const handleClose = (evt)=>{\n                if (evt.wasClean) {\n                    state = {\n                        __type: \"disconnected\"\n                    };\n                } else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, {\n                        closeEvent: evt\n                    }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt)=>__awaiter(this, void 0, void 0, function*() {\n                    disposeSocket();\n                    if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                    } else {\n                        yield new Promise((resolve)=>{\n                            const retryDelayMs = getNextRetryDelayMs();\n                            retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                        });\n                        attemptSocketConnection();\n                    }\n                });\n            const handleMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                    const responseBuffer = yield evt.data.arrayBuffer();\n                    switch(state.__type){\n                        case \"connecting\":\n                            if (responseBuffer.byteLength !== 0) {\n                                throw new Error(\"Encountered unexpected message while connecting\");\n                            }\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                            state = {\n                                __type: \"hello_req_sent\",\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey\n                            };\n                            break;\n                        case \"connected\":\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                    throw new Error(\"Encrypted message has invalid sequence number\");\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            } catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                } else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case \"hello_req_sent\":\n                            {\n                                // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)\n                                if (responseBuffer.byteLength === 0) {\n                                    const ecdhKeypair = yield generateECDHKeypair();\n                                    socket.send((yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey)));\n                                    state = {\n                                        __type: \"hello_req_sent\",\n                                        associationPublicKey: associationKeypair.publicKey,\n                                        ecdhPrivateKey: ecdhKeypair.privateKey\n                                    };\n                                    break;\n                                }\n                                const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                                const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                                const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (()=>__awaiter(this, void 0, void 0, function*() {\n                                        const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                        const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                        if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                            throw new Error(\"Encrypted message has invalid sequence number\");\n                                        }\n                                        lastKnownInboundSequenceNumber = sequenceNumber;\n                                        return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                    }))() : {\n                                    protocol_version: \"legacy\"\n                                };\n                                state = {\n                                    __type: \"connected\",\n                                    sharedSecret,\n                                    sessionProperties\n                                };\n                                const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params)=>__awaiter(this, void 0, void 0, function*() {\n                                        const id = nextJsonRpcMessageId++;\n                                        socket.send((yield encryptJsonRpcMessage({\n                                            id,\n                                            jsonrpc: \"2.0\",\n                                            method,\n                                            params: params !== null && params !== void 0 ? params : {}\n                                        }, sharedSecret)));\n                                        return new Promise((resolve, reject)=>{\n                                            jsonRpcResponsePromises[id] = {\n                                                resolve (result) {\n                                                    switch(method){\n                                                        case \"authorize\":\n                                                        case \"reauthorize\":\n                                                            {\n                                                                const { wallet_uri_base } = result;\n                                                                if (wallet_uri_base != null) {\n                                                                    try {\n                                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                                    } catch (e) {\n                                                                        reject(e);\n                                                                        return;\n                                                                    }\n                                                                }\n                                                                break;\n                                                            }\n                                                    }\n                                                    resolve(result);\n                                                },\n                                                reject\n                                            };\n                                        });\n                                    }));\n                                try {\n                                    resolve((yield callback(wallet)));\n                                } catch (e) {\n                                    reject(e);\n                                } finally{\n                                    disposeSocket();\n                                    socket.close();\n                                }\n                                break;\n                            }\n                    }\n                });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = ()=>{\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = {\n                    __type: \"connecting\",\n                    associationKeypair\n                };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [\n                    WEBSOCKET_PROTOCOL_BINARY\n                ]);\n                socket.addEventListener(\"open\", handleOpen);\n                socket.addEventListener(\"close\", handleClose);\n                socket.addEventListener(\"error\", handleError);\n                socket.addEventListener(\"message\", handleMessage);\n                disposeSocket = ()=>{\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"close\", handleClose);\n                    socket.removeEventListener(\"error\", handleError);\n                    socket.removeEventListener(\"message\", handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\nfunction transactRemote(callback, config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return startRemoteScenario(config).then((scenario)=>{\n            return {\n                associationUrl: scenario.associationUrl,\n                result: scenario.wallet.then((wallet)=>{\n                    return callback(new Proxy(wallet, {\n                        get (target, p) {\n                            if (p == \"terminateSession\") {\n                                return function() {\n                                    return __awaiter(this, void 0, void 0, function*() {\n                                        scenario.close();\n                                        return;\n                                    });\n                                };\n                            } else return target[p];\n                        }\n                    }));\n                })\n            };\n        });\n    });\n}\nfunction startRemoteScenario(config) {\n    return __awaiter(this, void 0, void 0, function*() {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (()=>{\n            const schedule = [\n                ...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs\n            ];\n            return ()=>schedule.length > 1 ? schedule.shift() : schedule[0];\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let encoding;\n        let state = {\n            __type: \"disconnected\"\n        };\n        let socket;\n        let disposeSocket;\n        let decodeBytes = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                if (encoding == \"base64\") {\n                    const message = yield evt.data;\n                    return toUint8Array(message).buffer;\n                } else {\n                    return yield evt.data.arrayBuffer();\n                }\n            });\n        // Reflector Connection Phase\n        // here we connect to the reflector and wait for the REFLECTOR_ID message \n        // so we build the association URL and return that back to the caller\n        const associationUrl = yield new Promise((resolve, reject)=>{\n            const handleOpen = ()=>__awaiter(this, void 0, void 0, function*() {\n                    if (state.__type !== \"connecting\") {\n                        console.warn(\"Expected adapter state to be `connecting` at the moment the websocket opens. \" + `Got \\`${state.__type}\\`.`);\n                        return;\n                    }\n                    if (socket.protocol.includes(WEBSOCKET_PROTOCOL_BASE64)) {\n                        encoding = \"base64\";\n                    } else {\n                        encoding = \"binary\";\n                    }\n                    socket.removeEventListener(\"open\", handleOpen);\n                });\n            const handleClose = (evt)=>{\n                if (evt.wasClean) {\n                    state = {\n                        __type: \"disconnected\"\n                    };\n                } else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, {\n                        closeEvent: evt\n                    }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt)=>__awaiter(this, void 0, void 0, function*() {\n                    disposeSocket();\n                    if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                    } else {\n                        yield new Promise((resolve)=>{\n                            const retryDelayMs = getNextRetryDelayMs();\n                            retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                        });\n                        attemptSocketConnection();\n                    }\n                });\n            const handleReflectorIdMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                    const responseBuffer = yield decodeBytes(evt);\n                    if (state.__type === \"connecting\") {\n                        if (responseBuffer.byteLength == 0) {\n                            throw new Error(\"Encountered unexpected message while connecting\");\n                        }\n                        const reflectorId = getReflectorIdFromByteArray(responseBuffer);\n                        state = {\n                            __type: \"reflector_id_received\",\n                            reflectorId: reflectorId\n                        };\n                        const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationKeypair.publicKey, config.remoteHostAuthority, reflectorId, config === null || config === void 0 ? void 0 : config.baseUri);\n                        socket.removeEventListener(\"message\", handleReflectorIdMessage);\n                        resolve(associationUrl);\n                    }\n                });\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = ()=>{\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = {\n                    __type: \"connecting\",\n                    associationKeypair\n                };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [\n                    WEBSOCKET_PROTOCOL_BINARY,\n                    WEBSOCKET_PROTOCOL_BASE64\n                ]);\n                socket.addEventListener(\"open\", handleOpen);\n                socket.addEventListener(\"close\", handleClose);\n                socket.addEventListener(\"error\", handleError);\n                socket.addEventListener(\"message\", handleReflectorIdMessage);\n                disposeSocket = ()=>{\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"close\", handleClose);\n                    socket.removeEventListener(\"error\", handleError);\n                    socket.removeEventListener(\"message\", handleReflectorIdMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n        // Wallet Connection Phase\n        // here we return the association URL (containing the reflector ID) to the caller + \n        // a promise that will resolve the MobileWallet object once the wallet connects.\n        let sessionEstablished = false;\n        let handleClose;\n        return {\n            associationUrl,\n            close: ()=>{\n                socket.close();\n                handleClose();\n            },\n            wallet: new Promise((resolve, reject)=>{\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const jsonRpcResponsePromises = {};\n                const handleMessage = (evt)=>__awaiter(this, void 0, void 0, function*() {\n                        const responseBuffer = yield decodeBytes(evt);\n                        switch(state.__type){\n                            case \"reflector_id_received\":\n                                if (responseBuffer.byteLength !== 0) {\n                                    throw new Error(\"Encountered unexpected message while awaiting reflection\");\n                                }\n                                const ecdhKeypair = yield generateECDHKeypair();\n                                const binaryMsg = yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey);\n                                if (encoding == \"base64\") {\n                                    socket.send(fromUint8Array(binaryMsg));\n                                } else {\n                                    socket.send(binaryMsg);\n                                }\n                                state = {\n                                    __type: \"hello_req_sent\",\n                                    associationPublicKey: associationKeypair.publicKey,\n                                    ecdhPrivateKey: ecdhKeypair.privateKey\n                                };\n                                break;\n                            case \"connected\":\n                                try {\n                                    const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                    if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                        throw new Error(\"Encrypted message has invalid sequence number\");\n                                    }\n                                    lastKnownInboundSequenceNumber = sequenceNumber;\n                                    const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                    const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                    delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                    responsePromise.resolve(jsonRpcMessage.result);\n                                } catch (e) {\n                                    if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                        const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                        delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                        responsePromise.reject(e);\n                                    } else {\n                                        throw e;\n                                    }\n                                }\n                                break;\n                            case \"hello_req_sent\":\n                                {\n                                    const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                                    const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                                    const sessionProperties = sessionPropertiesBuffer.byteLength !== 0 ? yield (()=>__awaiter(this, void 0, void 0, function*() {\n                                            const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                            if (sequenceNumber !== lastKnownInboundSequenceNumber + 1) {\n                                                throw new Error(\"Encrypted message has invalid sequence number\");\n                                            }\n                                            lastKnownInboundSequenceNumber = sequenceNumber;\n                                            return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                        }))() : {\n                                        protocol_version: \"legacy\"\n                                    };\n                                    state = {\n                                        __type: \"connected\",\n                                        sharedSecret,\n                                        sessionProperties\n                                    };\n                                    const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params)=>__awaiter(this, void 0, void 0, function*() {\n                                            const id = nextJsonRpcMessageId++;\n                                            const binaryMsg = yield encryptJsonRpcMessage({\n                                                id,\n                                                jsonrpc: \"2.0\",\n                                                method,\n                                                params: params !== null && params !== void 0 ? params : {}\n                                            }, sharedSecret);\n                                            if (encoding == \"base64\") {\n                                                socket.send(fromUint8Array(binaryMsg));\n                                            } else {\n                                                socket.send(binaryMsg);\n                                            }\n                                            return new Promise((resolve, reject)=>{\n                                                jsonRpcResponsePromises[id] = {\n                                                    resolve (result) {\n                                                        switch(method){\n                                                            case \"authorize\":\n                                                            case \"reauthorize\":\n                                                                {\n                                                                    const { wallet_uri_base } = result;\n                                                                    if (wallet_uri_base != null) {\n                                                                        try {\n                                                                            assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                                        } catch (e) {\n                                                                            reject(e);\n                                                                            return;\n                                                                        }\n                                                                    }\n                                                                    break;\n                                                                }\n                                                        }\n                                                        resolve(result);\n                                                    },\n                                                    reject\n                                                };\n                                            });\n                                        }));\n                                    sessionEstablished = true;\n                                    try {\n                                        resolve(wallet);\n                                    } catch (e) {\n                                        reject(e);\n                                    }\n                                    break;\n                                }\n                        }\n                    });\n                socket.addEventListener(\"message\", handleMessage);\n                handleClose = ()=>{\n                    socket.removeEventListener(\"message\", handleMessage);\n                    disposeSocket();\n                    if (!sessionEstablished) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session was closed before connection.`, {\n                            closeEvent: new CloseEvent(\"socket was closed before connection\")\n                        }));\n                    }\n                };\n            })\n        };\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFFdkUsK0VBQStFO0FBQy9FLE1BQU1DLHFDQUFxQztJQUN2Q0MscUNBQXFDO0lBQ3JDQyxpQ0FBaUM7SUFDakNDLGlDQUFpQztJQUNqQ0MsK0JBQStCO0lBQy9CQyxzQkFBc0I7SUFDdEJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQ0FBZ0M7SUFDaENDLDZCQUE2QjtBQUNqQztBQUNBLE1BQU1DLHVDQUF1Q0M7SUFDekNDLFlBQVksR0FBR0MsSUFBSSxDQUFFO1FBQ2pCLE1BQU0sQ0FBQ0MsTUFBTUMsU0FBU0MsS0FBSyxHQUFHSDtRQUM5QixLQUFLLENBQUNFO1FBQ04sSUFBSSxDQUFDRCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBLCtFQUErRTtBQUMvRSxNQUFNQyw2Q0FBNkM7SUFDL0MsOEVBQThFO0lBQzlFQyw0QkFBNEIsQ0FBQztJQUM3QkMsd0JBQXdCLENBQUM7SUFDekJDLGtCQUFrQixDQUFDO0lBQ25CQyxxQkFBcUIsQ0FBQztJQUN0QkMseUJBQXlCLENBQUM7SUFDMUJDLDZCQUE2QixDQUFDO0FBQ2xDO0FBQ0EsTUFBTUMsK0NBQStDZDtJQUNqREMsWUFBWSxHQUFHQyxJQUFJLENBQUU7UUFDakIsTUFBTSxDQUFDYSxrQkFBa0JaLE1BQU1DLFNBQVNDLEtBQUssR0FBR0g7UUFDaEQsS0FBSyxDQUFDRTtRQUNOLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ1UsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ1QsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU1UsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sT0FBT0MsS0FBSztJQUNqQixPQUFPQyxPQUFPQyxJQUFJLENBQUNGO0FBQ3ZCO0FBQ0EsU0FBU0csZUFBZUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3RDLE1BQU1DLFNBQVNMLE9BQU9DLElBQUksQ0FBQ0ssT0FBT0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsU0FBU0w7SUFDN0QsSUFBSUMsU0FBUztRQUNULE9BQU9DLE9BQ0ZJLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxPQUFPO0lBQ3hCLE9BRUksT0FBT0o7QUFDZjtBQUNBLFNBQVNLLGFBQWFDLHNCQUFzQjtJQUN4QyxPQUFPLElBQUlDLFdBQVdaLE9BQ2pCYSxJQUFJLENBQUNGLHdCQUNMRyxLQUFLLENBQUMsSUFDTkMsR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLFVBQVUsQ0FBQztBQUNqQztBQUVBLFNBQVNDLGVBQWVDLGFBQWEsRUFBRUMsNEJBQTRCO0lBQy9ELE9BQU96QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE1BQU0wQyxrQkFBa0IsTUFBTUMsT0FBT0MsTUFBTSxDQUFDQyxTQUFTLENBQUMsT0FBT0w7UUFDN0QsTUFBTU0sa0JBQWtCLE1BQU1ILE9BQU9DLE1BQU0sQ0FBQ0csSUFBSSxDQUFDO1lBQUVDLE1BQU07WUFBVzFELE1BQU07UUFBUSxHQUFHbUQsOEJBQThCQztRQUNuSCxNQUFNTyxXQUFXLElBQUloQixXQUFXUyxnQkFBZ0JRLFVBQVUsR0FBR0osZ0JBQWdCSSxVQUFVO1FBQ3ZGRCxTQUFTRSxHQUFHLENBQUMsSUFBSWxCLFdBQVdTLGtCQUFrQjtRQUM5Q08sU0FBU0UsR0FBRyxDQUFDLElBQUlsQixXQUFXYSxrQkFBa0JKLGdCQUFnQlEsVUFBVTtRQUN4RSxPQUFPRDtJQUNYO0FBQ0o7QUFFQSxTQUFTRyxrQkFBa0JDLE9BQU87SUFDOUIsT0FBT2pGLHFGQUF1QkEsQ0FBQ2lGO0FBQ25DO0FBQ0EsU0FBU0Msd0JBQXdCRCxPQUFPO0lBQ3BDLE9BQU9sQyxPQUFPaUMsa0JBQWtCQztBQUNwQztBQUVBLG9CQUFvQjtBQUNwQixNQUFNRSx5QkFBeUI7QUFDL0IsTUFBTUMsMkJBQTJCO0FBQ2pDLE1BQU1DLHlCQUF5QjtBQUUvQjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyx3QkFBd0JDLGVBQWUsRUFBRUMsc0JBQXNCO0lBQ3BFLE9BQU8sSUFBSUMsTUFBTSxDQUFDLEdBQUc7UUFDakJDLEtBQUlDLE1BQU0sRUFBRUMsQ0FBQztZQUNULGdHQUFnRztZQUNoRyx3R0FBd0c7WUFDeEcsNENBQTRDO1lBQzVDLFlBQVk7WUFDWixJQUFJQSxNQUFNLFFBQVE7Z0JBQ2QsT0FBTztZQUNYO1lBQ0EsSUFBSUQsTUFBTSxDQUFDQyxFQUFFLElBQUksTUFBTTtnQkFDbkJELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHLFNBQVVDLFdBQVc7b0JBQzdCLE9BQU9qRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO3dCQUNuQyxNQUFNLEVBQUVrRSxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQywwQkFBMEJKLEdBQUdDLGFBQWFOO3dCQUNyRSxNQUFNNUMsU0FBUyxNQUFNNkMsdUJBQXVCTSxRQUFRQzt3QkFDcEQsOEdBQThHO3dCQUM5RyxJQUFJRCxXQUFXLGVBQWVDLE9BQU9FLGVBQWUsSUFBSSxDQUFDdEQsT0FBT3VELGNBQWMsRUFBRTs0QkFDNUV2RCxNQUFNLENBQUMsaUJBQWlCLEdBQUcsTUFBTXdELGVBQWVKLE9BQU9FLGVBQWUsRUFBRXRELFFBQVE2Qzt3QkFDcEY7d0JBQ0EsT0FBT1ksMkJBQTJCUixHQUFHakQsUUFBUTRDO29CQUNqRDtnQkFDSjtZQUNKO1lBQ0EsT0FBT0ksTUFBTSxDQUFDQyxFQUFFO1FBQ3BCO1FBQ0FTO1lBQ0ksT0FBTztRQUNYO1FBQ0FDO1lBQ0ksT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU04sMEJBQTBCTyxVQUFVLEVBQUVDLFlBQVksRUFBRWpCLGVBQWU7SUFDeEUsSUFBSVEsU0FBU1M7SUFDYixJQUFJVixTQUFTUyxXQUNSRSxRQUFRLEdBQ1IvQyxPQUFPLENBQUMsVUFBVSxDQUFDZ0QsU0FBVyxDQUFDLENBQUMsRUFBRUEsT0FBT0MsV0FBVyxHQUFHLENBQUMsRUFDeERBLFdBQVc7SUFDaEIsT0FBUUo7UUFDSixLQUFLO1lBQWE7Z0JBQ2QsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBR2I7Z0JBQ2hCLElBQUlSLG9CQUFvQixVQUFVO29CQUM5QixPQUFRcUI7d0JBQ0osS0FBSzs0QkFBa0I7Z0NBQ25CQSxRQUFRO2dDQUNSOzRCQUNKO3dCQUNBLEtBQUs7NEJBQWlCO2dDQUNsQkEsUUFBUTtnQ0FDUjs0QkFDSjt3QkFDQSxLQUFLOzRCQUFrQjtnQ0FDbkJBLFFBQVE7Z0NBQ1I7NEJBQ0o7d0JBQ0E7NEJBQVM7Z0NBQ0xBLFFBQVFiLE9BQU9jLE9BQU87NEJBQzFCO29CQUNKO29CQUNBZCxPQUFPYyxPQUFPLEdBQUdEO2dCQUNyQixPQUNLO29CQUNELE9BQVFBO3dCQUNKLEtBQUs7d0JBQ0wsS0FBSzs0QkFBVTtnQ0FDWEEsUUFBUSxDQUFDLE9BQU8sRUFBRUEsTUFBTSxDQUFDO2dDQUN6Qjs0QkFDSjt3QkFDQSxLQUFLOzRCQUFnQjtnQ0FDakJBLFFBQVE7Z0NBQ1I7NEJBQ0o7b0JBQ0o7b0JBQ0FiLE9BQU9hLEtBQUssR0FBR0E7Z0JBQ25CO1lBQ0o7UUFDQSxLQUFLO1lBQWU7Z0JBQ2hCLE1BQU0sRUFBRUUsVUFBVSxFQUFFQyxRQUFRLEVBQUUsR0FBR2hCO2dCQUNqQyxJQUFJZSxZQUFZO29CQUNaLE9BQVF2Qjt3QkFDSixLQUFLOzRCQUFVO2dDQUNYTyxTQUFTO2dDQUNUQyxTQUFTO29DQUFFZSxZQUFZQTtvQ0FBWUMsVUFBVUE7Z0NBQVM7Z0NBQ3REOzRCQUNKO3dCQUNBOzRCQUFTO2dDQUNMakIsU0FBUztnQ0FDVDs0QkFDSjtvQkFDSjtnQkFDSjtnQkFDQTtZQUNKO0lBQ0o7SUFDQSxPQUFPO1FBQUVBO1FBQVFDO0lBQU87QUFDNUI7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssMkJBQTJCTixNQUFNLEVBQUVqQixRQUFRLEVBQUVVLGVBQWU7SUFDakUsT0FBUU87UUFDSixLQUFLO1lBQW1CO2dCQUNwQixNQUFNa0IsZUFBZW5DO2dCQUNyQixPQUFRVTtvQkFDSixLQUFLO3dCQUFVOzRCQUNYLE1BQU0wQixXQUFXO2dDQUFDOUI7NkJBQXVCOzRCQUN6QyxJQUFJNkIsYUFBYUUsNEJBQTRCLEtBQUssTUFBTTtnQ0FDcERELFNBQVNFLElBQUksQ0FBQy9COzRCQUNsQjs0QkFDQSxPQUFPZ0MsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHTCxlQUFlO2dDQUFFQyxVQUFVQTs0QkFBUzt3QkFDL0U7b0JBQ0EsS0FBSzt3QkFBTTs0QkFDUCxPQUFPRyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdMLGVBQWU7Z0NBQUVNLHFDQUFxQztnQ0FBTUosOEJBQThCRixhQUFhQyxRQUFRLENBQUNNLFFBQVEsQ0FBQ25DOzRCQUEwQjt3QkFDOUw7Z0JBQ0o7WUFDSjtJQUNKO0lBQ0EsT0FBT1A7QUFDWDtBQUNBLFNBQVNzQixlQUFlcUIsYUFBYSxFQUFFQyxtQkFBbUIsRUFBRWpDLHNCQUFzQjtJQUM5RSxJQUFJa0M7SUFDSixPQUFPOUYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxNQUFNK0YsU0FBUyxDQUFDRCxLQUFLRixjQUFjRyxNQUFNLE1BQU0sUUFBUUQsT0FBTyxLQUFLLElBQUlBLEtBQUt6RSxPQUFPMkUsUUFBUSxDQUFDQyxJQUFJO1FBQ2hHLE1BQU1DLFVBQVVMLG9CQUFvQk0sUUFBUSxDQUFDLEVBQUUsQ0FBQ0QsT0FBTztRQUN2RCxNQUFNRSxjQUFjOUMsd0JBQXdCa0MsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHRyxnQkFBZ0I7WUFBRUc7WUFBUUc7UUFBUTtRQUM5RyxNQUFNRyxvQkFBb0IsTUFBTXpDLHVCQUF1QixpQkFBaUI7WUFDcEUwQyxXQUFXO2dCQUFDSjthQUFRO1lBQ3BCSyxVQUFVO2dCQUFDSDthQUFZO1FBQzNCO1FBQ0EsTUFBTUksZUFBZTtZQUNqQk4sU0FBU0E7WUFDVE8sZ0JBQWdCTDtZQUNoQk0sV0FBV0wsa0JBQWtCTSxlQUFlLENBQUMsRUFBRSxDQUFDQyxLQUFLLENBQUNSLFlBQVlTLE1BQU07UUFDNUU7UUFDQSxPQUFPTDtJQUNYO0FBQ0o7QUFFQSxNQUFNTSx3QkFBd0I7QUFDOUIsU0FBU0MsMkJBQTJCQyxjQUFjO0lBQzlDLElBQUlBLGtCQUFrQixZQUFZO1FBQzlCLE1BQU0sSUFBSWhJLE1BQU07SUFDcEI7SUFDQSxNQUFNd0MsWUFBWSxJQUFJeUYsWUFBWUg7SUFDbEMsTUFBTUksT0FBTyxJQUFJQyxTQUFTM0Y7SUFDMUIwRixLQUFLRSxTQUFTLENBQUMsR0FBR0osZ0JBQWdCLGdCQUFnQixHQUFHO0lBQ3JELE9BQU8sSUFBSS9FLFdBQVdUO0FBQzFCO0FBRUEsTUFBTTZGLDhCQUE4QjtBQUNwQyxNQUFNQyxrQ0FBa0M7QUFDeEMsU0FBU0MsZUFBZUMsU0FBUyxFQUFFUixjQUFjLEVBQUVTLFlBQVk7SUFDM0QsT0FBT3pILFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsTUFBTTBILHVCQUF1QlgsMkJBQTJCQztRQUN4RCxNQUFNVyx1QkFBdUIsSUFBSTFGLFdBQVdvRjtRQUM1QzFFLE9BQU9pRixlQUFlLENBQUNEO1FBQ3ZCLE1BQU1FLGFBQWEsTUFBTWxGLE9BQU9DLE1BQU0sQ0FBQ2tGLE9BQU8sQ0FBQ0MsbUJBQW1CTCxzQkFBc0JDLHVCQUF1QkYsY0FBYyxJQUFJTyxjQUFjN0csTUFBTSxDQUFDcUc7UUFDdEosTUFBTXZFLFdBQVcsSUFBSWhCLFdBQVd5RixxQkFBcUJ4RSxVQUFVLEdBQUd5RSxxQkFBcUJ6RSxVQUFVLEdBQUcyRSxXQUFXM0UsVUFBVTtRQUN6SEQsU0FBU0UsR0FBRyxDQUFDLElBQUlsQixXQUFXeUYsdUJBQXVCO1FBQ25EekUsU0FBU0UsR0FBRyxDQUFDLElBQUlsQixXQUFXMEYsdUJBQXVCRCxxQkFBcUJ4RSxVQUFVO1FBQ2xGRCxTQUFTRSxHQUFHLENBQUMsSUFBSWxCLFdBQVc0RixhQUFhSCxxQkFBcUJ4RSxVQUFVLEdBQUd5RSxxQkFBcUJ6RSxVQUFVO1FBQzFHLE9BQU9EO0lBQ1g7QUFDSjtBQUNBLFNBQVNnRixlQUFlN0ksT0FBTyxFQUFFcUksWUFBWTtJQUN6QyxPQUFPekgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxNQUFNMEgsdUJBQXVCdEksUUFBUXdILEtBQUssQ0FBQyxHQUFHRTtRQUM5QyxNQUFNYSx1QkFBdUJ2SSxRQUFRd0gsS0FBSyxDQUFDRSx1QkFBdUJBLHdCQUF3Qk87UUFDMUYsTUFBTVEsYUFBYXpJLFFBQVF3SCxLQUFLLENBQUNFLHdCQUF3Qk87UUFDekQsTUFBTWEsa0JBQWtCLE1BQU12RixPQUFPQyxNQUFNLENBQUN1RixPQUFPLENBQUNKLG1CQUFtQkwsc0JBQXNCQyx1QkFBdUJGLGNBQWNJO1FBQ2xJLE1BQU1MLFlBQVlZLGlCQUFpQkMsTUFBTSxDQUFDSDtRQUMxQyxPQUFPVjtJQUNYO0FBQ0o7QUFDQSxTQUFTTyxtQkFBbUJmLGNBQWMsRUFBRVcsb0JBQW9CO0lBQzVELE9BQU87UUFDSFcsZ0JBQWdCdEI7UUFDaEJ1QixJQUFJWjtRQUNKckksTUFBTTtRQUNOa0osV0FBVztJQUNmO0FBQ0o7QUFDQSxJQUFJQztBQUNKLFNBQVNMO0lBQ0wsSUFBSUssaUJBQWlCQyxXQUFXO1FBQzVCRCxlQUFlLElBQUlFLFlBQVk7SUFDbkM7SUFDQSxPQUFPRjtBQUNYO0FBRUEsU0FBU0c7SUFDTCxPQUFPNUksVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPLE1BQU0yQyxPQUFPQyxNQUFNLENBQUNpRyxXQUFXLENBQUM7WUFDbkN2SixNQUFNO1lBQ053SixZQUFZO1FBQ2hCLEdBQUcsT0FBeUI7WUFBQztTQUFPO0lBQ3hDO0FBQ0o7QUFFQSxTQUFTQztJQUNMLE9BQU8vSSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE9BQU8sTUFBTTJDLE9BQU9DLE1BQU0sQ0FBQ2lHLFdBQVcsQ0FBQztZQUNuQ3ZKLE1BQU07WUFDTndKLFlBQVk7UUFDaEIsR0FBRyxPQUF5QjtZQUFDO1lBQWE7U0FBYTtJQUMzRDtBQUNKO0FBRUEsNkNBQTZDO0FBQzdDLFNBQVNFLDBCQUEwQkMsTUFBTTtJQUNyQyxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsUUFBUSxJQUFJbEgsV0FBV2dIO0lBQzdCLE1BQU1HLE1BQU1ELE1BQU1qRyxVQUFVO0lBQzVCLElBQUssSUFBSW1HLEtBQUssR0FBR0EsS0FBS0QsS0FBS0MsS0FBTTtRQUM3QkgsVUFBVXZILE9BQU9DLFlBQVksQ0FBQ3VILEtBQUssQ0FBQ0UsR0FBRztJQUMzQztJQUNBLE9BQU9oSSxPQUFPQyxJQUFJLENBQUM0SDtBQUN2QjtBQUVBLFNBQVNJO0lBQ0wsT0FBT0Msc0JBQXNCLFFBQVFDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNLFNBQVEsUUFBUTtBQUNyRjtBQUNBLFNBQVNILHNCQUFzQkksSUFBSTtJQUMvQixJQUFJQSxPQUFPLFNBQVNBLE9BQU8sT0FBTztRQUM5QixNQUFNLElBQUk1SywrQkFBK0JWLG1DQUFtQ0MsbUNBQW1DLEVBQUUsQ0FBQyx5REFBeUQsRUFBRXFMLEtBQUssT0FBTyxDQUFDLEVBQUU7WUFBRUE7UUFBSztJQUN2TTtJQUNBLE9BQU9BO0FBQ1g7QUFFQSxTQUFTQyx5Q0FBeUNDLHlCQUF5QjtJQUN2RSxPQUFPQSwwQkFBMEIvSCxPQUFPLENBQUMsVUFBVSxDQUFDZ0ksSUFBTztZQUN2RCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7UUFDVCxFQUFDLENBQUNBLEVBQUU7QUFDUjtBQUVBLE1BQU1DLGNBQWM7QUFDcEIsU0FBU0MsYUFBYUMsVUFBVTtJQUM1QixPQUFRQSxVQUNKLHFDQUFxQztLQUNwQ25JLE9BQU8sQ0FBQyxnQkFBZ0IsR0FDekIsaUNBQWlDO0tBQ2hDSyxLQUFLLENBQUM7QUFDZjtBQUNBLFNBQVMrSCxhQUFhQyxjQUFjLEVBQUVDLGFBQWE7SUFDL0MsSUFBSUMsVUFBVTtJQUNkLElBQUlELGVBQWU7UUFDZixJQUFJO1lBQ0FDLFVBQVUsSUFBSUMsSUFBSUY7UUFDdEIsRUFDQSxPQUFPdEUsSUFBSSxDQUFFLEVBQUUsK0JBQStCO1FBQzlDLElBQUksQ0FBQ3VFLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRSxRQUFRLE1BQU0sVUFBVTtZQUNuRixNQUFNLElBQUl4TCwrQkFBK0JWLG1DQUFtQ0csK0JBQStCLEVBQUU7UUFDakg7SUFDSjtJQUNBNkwsV0FBWUEsQ0FBQUEsVUFBVSxJQUFJQyxJQUFJLENBQUMsRUFBRVAsWUFBWSxFQUFFLENBQUM7SUFDaEQsTUFBTVMsV0FBV0wsZUFBZU0sVUFBVSxDQUFDLE9BRW5DTixpQkFFQTtXQUFJSCxhQUFhSyxRQUFRRyxRQUFRO1dBQU1SLGFBQWFHO0tBQWdCLENBQUNPLElBQUksQ0FBQztJQUNsRixPQUFPLElBQUlKLElBQUlFLFVBQVVIO0FBQzdCO0FBQ0EsU0FBU00sNkJBQTZCQyxvQkFBb0IsRUFBRUMsWUFBWSxFQUFFQyxrQkFBa0IsRUFBRUMsbUJBQW1CO0lBQUM7Q0FBSztJQUNuSCxPQUFPL0ssVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxNQUFNZ0wsa0JBQWtCekIsc0JBQXNCc0I7UUFDOUMsTUFBTUksY0FBYyxNQUFNdEksT0FBT0MsTUFBTSxDQUFDQyxTQUFTLENBQUMsT0FBTytIO1FBQ3pELE1BQU1NLGFBQWFsQywwQkFBMEJpQztRQUM3QyxNQUFNRSxNQUFNakIsYUFBYSxzQkFBc0JZO1FBQy9DSyxJQUFJQyxZQUFZLENBQUNqSSxHQUFHLENBQUMsZUFBZXlHLHlDQUF5Q3NCO1FBQzdFQyxJQUFJQyxZQUFZLENBQUNqSSxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU2SCxnQkFBZ0IsQ0FBQztRQUNqREQsaUJBQWlCTSxPQUFPLENBQUMsQ0FBQ0M7WUFDdEJILElBQUlDLFlBQVksQ0FBQ2pJLEdBQUcsQ0FBQyxLQUFLbUk7UUFDOUI7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFDQSxTQUFTSSxtQ0FBbUNYLG9CQUFvQixFQUFFWSxhQUFhLEVBQUVDLFdBQVcsRUFBRVgsa0JBQWtCLEVBQUVDLG1CQUFtQjtJQUFDO0NBQUs7SUFDdkksT0FBTy9LLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsTUFBTWlMLGNBQWMsTUFBTXRJLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDLE9BQU8rSDtRQUN6RCxNQUFNTSxhQUFhbEMsMEJBQTBCaUM7UUFDN0MsTUFBTUUsTUFBTWpCLGFBQWEsdUJBQXVCWTtRQUNoREssSUFBSUMsWUFBWSxDQUFDakksR0FBRyxDQUFDLGVBQWV5Ryx5Q0FBeUNzQjtRQUM3RUMsSUFBSUMsWUFBWSxDQUFDakksR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFcUksY0FBYyxDQUFDO1FBQ3BETCxJQUFJQyxZQUFZLENBQUNqSSxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU1QixlQUFla0ssYUFBYSxNQUFNLENBQUM7UUFDakVWLGlCQUFpQk0sT0FBTyxDQUFDLENBQUNDO1lBQ3RCSCxJQUFJQyxZQUFZLENBQUNqSSxHQUFHLENBQUMsS0FBS21JO1FBQzlCO1FBQ0EsT0FBT0g7SUFDWDtBQUNKO0FBRUEsU0FBU08sc0JBQXNCQyxjQUFjLEVBQUVsRSxZQUFZO0lBQ3ZELE9BQU96SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE1BQU13SCxZQUFZb0UsS0FBS0MsU0FBUyxDQUFDRjtRQUNqQyxNQUFNM0UsaUJBQWlCMkUsZUFBZUcsRUFBRTtRQUN4QyxPQUFPdkUsZUFBZUMsV0FBV1IsZ0JBQWdCUztJQUNyRDtBQUNKO0FBQ0EsU0FBU3NFLHNCQUFzQjNNLE9BQU8sRUFBRXFJLFlBQVk7SUFDaEQsT0FBT3pILFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsTUFBTXdILFlBQVksTUFBTVMsZUFBZTdJLFNBQVNxSTtRQUNoRCxNQUFNa0UsaUJBQWlCQyxLQUFLSSxLQUFLLENBQUN4RTtRQUNsQyxJQUFJaEMsT0FBT3lHLGNBQWMsQ0FBQ3BLLElBQUksQ0FBQzhKLGdCQUFnQixVQUFVO1lBQ3JELE1BQU0sSUFBSTdMLHVDQUF1QzZMLGVBQWVHLEVBQUUsRUFBRUgsZUFBZU8sS0FBSyxDQUFDL00sSUFBSSxFQUFFd00sZUFBZU8sS0FBSyxDQUFDOU0sT0FBTztRQUMvSDtRQUNBLE9BQU91TTtJQUNYO0FBQ0o7QUFFQSxTQUFTUSxjQUFjQyxhQUFhLEVBQ3BDeEIsb0JBQW9CLEVBQUV5QixjQUFjO0lBQ2hDLE9BQU9yTSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE1BQU0sQ0FBQ3NNLDRCQUE0QkMsZ0JBQWdCLEdBQUcsTUFBTS9MLFFBQVFnTSxHQUFHLENBQUM7WUFDcEU3SixPQUFPQyxNQUFNLENBQUNDLFNBQVMsQ0FBQyxPQUFPK0g7WUFDL0JqSSxPQUFPQyxNQUFNLENBQUM2SixTQUFTLENBQUMsT0FBT0wsY0FBY3hGLEtBQUssQ0FBQyxHQUFHVSxrQ0FBa0M7Z0JBQUVoSSxNQUFNO2dCQUFRd0osWUFBWTtZQUFRLEdBQUcsT0FBeUIsRUFBRTtTQUM3SjtRQUNELE1BQU1yQixlQUFlLE1BQU05RSxPQUFPQyxNQUFNLENBQUM4SixVQUFVLENBQUM7WUFBRXBOLE1BQU07WUFBUXFOLFFBQVFKO1FBQWdCLEdBQUdGLGdCQUFnQjtRQUMvRyxNQUFNTyxnQkFBZ0IsTUFBTWpLLE9BQU9DLE1BQU0sQ0FBQzZKLFNBQVMsQ0FBQyxPQUFPaEYsY0FBYyxRQUFRLE9BQXlCO1lBQUM7U0FBWTtRQUN2SCxNQUFNb0Ysb0JBQW9CLE1BQU1sSyxPQUFPQyxNQUFNLENBQUNrSyxTQUFTLENBQUM7WUFDcER4TixNQUFNO1lBQ04wRCxNQUFNO1lBQ04rSixNQUFNLElBQUk5SyxXQUFXcUs7WUFDckJVLE1BQU0sSUFBSS9LO1FBQ2QsR0FBRzJLLGVBQWU7WUFBRXROLE1BQU07WUFBV3VILFFBQVE7UUFBSSxHQUFHLE9BQXlCO1lBQUM7WUFBVztTQUFVO1FBQ25HLE9BQU9nRztJQUNYO0FBQ0o7QUFFQSxTQUFTSSxrQkFBa0I3TixPQUFPLEVBQUVxSSxZQUFZO0lBQzVDLE9BQU96SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE1BQU13SCxZQUFZLE1BQU1TLGVBQWU3SSxTQUFTcUk7UUFDaEQsTUFBTXlGLGlCQUFpQnRCLEtBQUtJLEtBQUssQ0FBQ3hFO1FBQ2xDLElBQUk3RCxrQkFBa0I7UUFDdEIsSUFBSTZCLE9BQU95RyxjQUFjLENBQUNwSyxJQUFJLENBQUNxTCxnQkFBZ0IsTUFBTTtZQUNqRCxPQUFRQSxlQUFlQyxDQUFDO2dCQUNwQixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDRHhKLGtCQUFrQjtvQkFDbEI7Z0JBQ0osS0FBSztvQkFDREEsa0JBQWtCO29CQUNsQjtnQkFDSjtvQkFDSSxNQUFNLElBQUk1RSwrQkFBK0JWLG1DQUFtQ1EsOEJBQThCLEVBQUUsQ0FBQyxzQ0FBc0MsRUFBRXFPLGVBQWVDLENBQUMsQ0FBQyxDQUFDO1lBQy9LO1FBQ0o7UUFDQSxPQUFRO1lBQ0pDLGtCQUFrQnpKO1FBQ3RCO0lBQ0o7QUFDSjtBQUVBLCtFQUErRTtBQUMvRSxNQUFNMEosVUFBVTtJQUNaQyxTQUFTO0lBQ1RDLE9BQU87QUFDWDtBQUNBLFNBQVNDLGtCQUFrQkMsQ0FBQztJQUN4QixPQUFPQTtBQUNYO0FBQ0EsU0FBU0M7SUFDTCxPQUFPQyxVQUFVQyxTQUFTLENBQUNDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJUixRQUFRQyxPQUFPLEdBQUdELFFBQVFFLEtBQUs7QUFDM0Y7QUFDQSxTQUFTTztJQUNMLHlFQUF5RTtJQUN6RSxxRUFBcUU7SUFDckUsOERBQThEO0lBQzlELE9BQU8sSUFBSXROLFFBQVEsQ0FBQ0QsU0FBU0U7UUFDekIsU0FBU3NOO1lBQ0xDLGFBQWFDO1lBQ2I1TSxPQUFPNk0sbUJBQW1CLENBQUMsUUFBUUM7UUFDdkM7UUFDQSxTQUFTQTtZQUNMSjtZQUNBeE47UUFDSjtRQUNBYyxPQUFPK00sZ0JBQWdCLENBQUMsUUFBUUQ7UUFDaEMsTUFBTUYsWUFBWUksV0FBVztZQUN6Qk47WUFDQXROO1FBQ0osR0FBRztJQUNQO0FBQ0o7QUFDQSxJQUFJNk4sU0FBUztBQUNiLFNBQVNDLDRCQUE0QnBELEdBQUc7SUFDcEMsSUFBSW1ELFVBQVUsTUFBTTtRQUNoQkEsU0FBU0UsU0FBU0MsYUFBYSxDQUFDO1FBQ2hDSCxPQUFPSSxLQUFLLENBQUNDLE9BQU8sR0FBRztRQUN2QkgsU0FBU0ksSUFBSSxDQUFDQyxXQUFXLENBQUNQO0lBQzlCO0lBQ0Esb0VBQW9FO0lBQ3BFQSxPQUFPUSxhQUFhLENBQUM5SSxRQUFRLENBQUMrSSxJQUFJLEdBQUc1RCxJQUFJdEcsUUFBUTtBQUNyRDtBQUNBLFNBQVNtSyxrQkFBa0JDLGNBQWM7SUFDckMsT0FBT2pQLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsSUFBSWlQLGVBQWUxRSxRQUFRLEtBQUssVUFBVTtZQUN0Qyx3RUFBd0U7WUFDeEUsc0VBQXNFO1lBQ3RFLHlEQUF5RDtZQUN6RGxKLE9BQU8yRSxRQUFRLENBQUNQLE1BQU0sQ0FBQ3dKO1FBQzNCLE9BQ0s7WUFDRCxtRUFBbUU7WUFDbkUsSUFBSTtnQkFDQSxNQUFNQyxVQUFVeEI7Z0JBQ2hCLE9BQVF3QjtvQkFDSixLQUFLN0IsUUFBUUMsT0FBTzt3QkFDaEIsK0RBQStEO3dCQUMvRGlCLDRCQUE0QlU7d0JBRTVCO29CQUNKLEtBQUs1QixRQUFRRSxLQUFLO3dCQUFFOzRCQUNoQixNQUFNNEIsbUJBQW1CckI7NEJBQ3pCek0sT0FBTzJFLFFBQVEsQ0FBQ1AsTUFBTSxDQUFDd0o7NEJBQ3ZCLE1BQU1FOzRCQUNOO3dCQUNKO29CQUNBO3dCQUNJM0Isa0JBQWtCMEI7Z0JBQzFCO1lBQ0osRUFDQSxPQUFPck8sR0FBRztnQkFDTixNQUFNLElBQUk5QiwrQkFBK0JWLG1DQUFtQ08sc0JBQXNCLEVBQUU7WUFDeEc7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTd1EsYUFBYXhFLG9CQUFvQixFQUFFRSxrQkFBa0I7SUFDMUQsT0FBTzlLLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsTUFBTXFQLHdCQUF3Qi9GO1FBQzlCLE1BQU0yRixpQkFBaUIsTUFBTXRFLDZCQUE2QkMsc0JBQXNCeUUsdUJBQXVCdkU7UUFDdkcsTUFBTWtFLGtCQUFrQkM7UUFDeEIsT0FBT0k7SUFDWDtBQUNKO0FBRUEsTUFBTUMsOEJBQThCO0lBQ2hDOzs7Ozs7Ozs7S0FTQyxHQUNEQyxzQkFBc0I7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO0tBQUs7SUFDL0RDLFdBQVc7QUFDZjtBQUNBLE1BQU1DLDRCQUE0QjtBQUNsQyxNQUFNQyw0QkFBNEI7QUFDbEMsU0FBU0M7SUFDTCxJQUFJLElBQWdFLEVBQUU7UUFDbEUsTUFBTSxJQUFJNVEsK0JBQStCVixtQ0FBbUNJLDZCQUE2QixFQUFFO0lBQy9HO0FBQ0o7QUFDQSxTQUFTb1IsZ0NBQWdDQyxhQUFhO0lBQ2xELElBQUkzRTtJQUNKLElBQUk7UUFDQUEsTUFBTSxJQUFJYixJQUFJd0Y7SUFDbEIsRUFDQSxPQUFPaEssSUFBSTtRQUNQLE1BQU0sSUFBSS9HLCtCQUErQlYsbUNBQW1DRywrQkFBK0IsRUFBRTtJQUNqSDtJQUNBLElBQUkyTSxJQUFJWixRQUFRLEtBQUssVUFBVTtRQUMzQixNQUFNLElBQUl4TCwrQkFBK0JWLG1DQUFtQ0csK0JBQStCLEVBQUU7SUFDakg7QUFDSjtBQUNBLFNBQVN1UiwrQkFBK0J2TyxTQUFTO0lBQzdDLE1BQU0wRixPQUFPLElBQUlDLFNBQVMzRjtJQUMxQixPQUFPMEYsS0FBSzhJLFNBQVMsQ0FBQyxHQUFHLGdCQUFnQixHQUFHO0FBQ2hEO0FBQ0EsU0FBU0MsY0FBY3pPLFNBQVM7SUFDNUIsSUFBSTJILFFBQVEsSUFBSWxILFdBQVdULFlBQVkwTyxJQUFJMU8sVUFBVTBCLFVBQVUsRUFBRWlOLFFBQVEsSUFBSTdQLFFBQVEsR0FBRzhQLFNBQVMsR0FBR0M7SUFDcEcsR0FBRztRQUNDLElBQUlELFVBQVVGLEtBQUtFLFNBQVNELE9BQ3hCLE1BQU0sSUFBSUcsV0FBVztRQUN6QkQsSUFBSWxILEtBQUssQ0FBQ2lILFNBQVM7UUFDbkI5UCxTQUFTLENBQUMrUCxJQUFJLElBQUcsS0FBTyxJQUFJRDtJQUNoQyxRQUFTQyxLQUFLLE1BQU07SUFDcEIsT0FBTztRQUFFL1A7UUFBTzhQO0lBQU87QUFDM0I7QUFDQSxTQUFTRyw0QkFBNEIvTyxTQUFTO0lBQzFDLElBQUksRUFBRWxCLE9BQU91RyxNQUFNLEVBQUV1SixNQUFNLEVBQUUsR0FBR0gsY0FBY3pPO0lBQzlDLE9BQU8sSUFBSVMsV0FBV1QsVUFBVW9GLEtBQUssQ0FBQ3dKLFFBQVFBLFNBQVN2SjtBQUMzRDtBQUNBLFNBQVMySixTQUFTQyxRQUFRLEVBQUVDLE1BQU07SUFDOUIsT0FBTzFRLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMyUDtRQUNBLE1BQU1nQixxQkFBcUIsTUFBTS9IO1FBQ2pDLE1BQU1nSSxjQUFjLE1BQU14QixhQUFhdUIsbUJBQW1CRSxTQUFTLEVBQUVILFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPSSxPQUFPO1FBQ25JLE1BQU1DLGVBQWUsQ0FBQyxlQUFlLEVBQUVILFlBQVksY0FBYyxDQUFDO1FBQ2xFLElBQUlJO1FBQ0osTUFBTUMsc0JBQXNCLENBQUM7WUFDekIsTUFBTUMsV0FBVzttQkFBSTVCLDRCQUE0QkMsb0JBQW9CO2FBQUM7WUFDdEUsT0FBTyxJQUFPMkIsU0FBU3JLLE1BQU0sR0FBRyxJQUFJcUssU0FBU0MsS0FBSyxLQUFLRCxRQUFRLENBQUMsRUFBRTtRQUN0RTtRQUNBLElBQUlFLHVCQUF1QjtRQUMzQixJQUFJQyxpQ0FBaUM7UUFDckMsSUFBSUMsUUFBUTtZQUFFQyxRQUFRO1FBQWU7UUFDckMsT0FBTyxJQUFJL1EsUUFBUSxDQUFDRCxTQUFTRTtZQUN6QixJQUFJK1E7WUFDSiw4REFBOEQ7WUFDOUQsTUFBTUMsMEJBQTBCLENBQUM7WUFDakMsTUFBTUMsYUFBYSxJQUFNMVIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDckQsSUFBSXNSLE1BQU1DLE1BQU0sS0FBSyxjQUFjO3dCQUMvQkksUUFBUUMsSUFBSSxDQUFDLGtGQUNULENBQUMsTUFBTSxFQUFFTixNQUFNQyxNQUFNLENBQUMsR0FBRyxDQUFDO3dCQUM5QjtvQkFDSjtvQkFDQUMsT0FBT3RELG1CQUFtQixDQUFDLFFBQVF3RDtvQkFDbkMsMkZBQTJGO29CQUMzRixzRkFBc0Y7b0JBQ3RGLDhGQUE4RjtvQkFDOUYsc0ZBQXNGO29CQUN0RiwrRkFBK0Y7b0JBQy9GLDJGQUEyRjtvQkFDM0YsTUFBTSxFQUFFZixrQkFBa0IsRUFBRSxHQUFHVztvQkFDL0IsTUFBTU8sY0FBYyxNQUFNOUk7b0JBQzFCeUksT0FBT00sSUFBSSxDQUFDLE9BQU12UCxlQUFlc1AsWUFBWWhCLFNBQVMsRUFBRUYsbUJBQW1Cb0IsVUFBVTtvQkFDckZULFFBQVE7d0JBQ0pDLFFBQVE7d0JBQ1IzRyxzQkFBc0IrRixtQkFBbUJFLFNBQVM7d0JBQ2xEeEUsZ0JBQWdCd0YsWUFBWUUsVUFBVTtvQkFDMUM7Z0JBQ0o7WUFDQSxNQUFNQyxjQUFjLENBQUNDO2dCQUNqQixJQUFJQSxJQUFJQyxRQUFRLEVBQUU7b0JBQ2RaLFFBQVE7d0JBQUVDLFFBQVE7b0JBQWU7Z0JBQ3JDLE9BQ0s7b0JBQ0Q5USxPQUFPLElBQUkxQiwrQkFBK0JWLG1DQUFtQ0ssb0JBQW9CLEVBQUUsQ0FBQyx5Q0FBeUMsRUFBRXVULElBQUk5UyxJQUFJLENBQUMsRUFBRSxFQUFFOFMsSUFBSUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUFFQyxZQUFZSDtvQkFBSTtnQkFDbE07Z0JBQ0FJO1lBQ0o7WUFDQSxNQUFNQyxjQUFjLENBQUNDLE9BQVN2UyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO29CQUMxRHFTO29CQUNBLElBQUlHLEtBQUtDLEdBQUcsS0FBS3pCLHVCQUF1QjFCLDRCQUE0QkUsU0FBUyxFQUFFO3dCQUMzRS9PLE9BQU8sSUFBSTFCLCtCQUErQlYsbUNBQW1DTSxxQkFBcUIsRUFBRSxDQUFDLDZDQUE2QyxFQUFFb1MsYUFBYSxDQUFDLENBQUM7b0JBQ3ZLLE9BQ0s7d0JBQ0QsTUFBTSxJQUFJdlEsUUFBUSxDQUFDRDs0QkFDZixNQUFNbVMsZUFBZXpCOzRCQUNyQjBCLHFCQUFxQnRSLE9BQU9nTixVQUFVLENBQUM5TixTQUFTbVM7d0JBQ3BEO3dCQUNBRTtvQkFDSjtnQkFDSjtZQUNBLE1BQU1DLGdCQUFnQixDQUFDWixNQUFRalMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDM0QsTUFBTThTLGlCQUFpQixNQUFNYixJQUFJNVMsSUFBSSxDQUFDMFQsV0FBVztvQkFDakQsT0FBUXpCLE1BQU1DLE1BQU07d0JBQ2hCLEtBQUs7NEJBQ0QsSUFBSXVCLGVBQWU1UCxVQUFVLEtBQUssR0FBRztnQ0FDakMsTUFBTSxJQUFJbEUsTUFBTTs0QkFDcEI7NEJBQ0EsTUFBTTZTLGNBQWMsTUFBTTlJOzRCQUMxQnlJLE9BQU9NLElBQUksQ0FBQyxPQUFNdlAsZUFBZXNQLFlBQVloQixTQUFTLEVBQUVGLG1CQUFtQm9CLFVBQVU7NEJBQ3JGVCxRQUFRO2dDQUNKQyxRQUFRO2dDQUNSM0csc0JBQXNCK0YsbUJBQW1CRSxTQUFTO2dDQUNsRHhFLGdCQUFnQndGLFlBQVlFLFVBQVU7NEJBQzFDOzRCQUNBO3dCQUNKLEtBQUs7NEJBQ0QsSUFBSTtnQ0FDQSxNQUFNckssdUJBQXVCb0wsZUFBZWxNLEtBQUssQ0FBQyxHQUFHRTtnQ0FDckQsTUFBTUUsaUJBQWlCK0ksK0JBQStCckk7Z0NBQ3RELElBQUlWLG1CQUFvQnFLLGlDQUFpQyxHQUFJO29DQUN6RCxNQUFNLElBQUlyUyxNQUFNO2dDQUNwQjtnQ0FDQXFTLGlDQUFpQ3JLO2dDQUNqQyxNQUFNMkUsaUJBQWlCLE1BQU1JLHNCQUFzQitHLGdCQUFnQnhCLE1BQU03SixZQUFZO2dDQUNyRixNQUFNdUwsa0JBQWtCdkIsdUJBQXVCLENBQUM5RixlQUFlRyxFQUFFLENBQUM7Z0NBQ2xFLE9BQU8yRix1QkFBdUIsQ0FBQzlGLGVBQWVHLEVBQUUsQ0FBQztnQ0FDakRrSCxnQkFBZ0J6UyxPQUFPLENBQUNvTCxlQUFlNUssTUFBTTs0QkFDakQsRUFDQSxPQUFPRixHQUFHO2dDQUNOLElBQUlBLGFBQWFmLHdDQUF3QztvQ0FDckQsTUFBTWtULGtCQUFrQnZCLHVCQUF1QixDQUFDNVEsRUFBRWQsZ0JBQWdCLENBQUM7b0NBQ25FLE9BQU8wUix1QkFBdUIsQ0FBQzVRLEVBQUVkLGdCQUFnQixDQUFDO29DQUNsRGlULGdCQUFnQnZTLE1BQU0sQ0FBQ0k7Z0NBQzNCLE9BQ0s7b0NBQ0QsTUFBTUE7Z0NBQ1Y7NEJBQ0o7NEJBQ0E7d0JBQ0osS0FBSzs0QkFBa0I7Z0NBQ25CLHNGQUFzRjtnQ0FDdEYsSUFBSWlTLGVBQWU1UCxVQUFVLEtBQUssR0FBRztvQ0FDakMsTUFBTTJPLGNBQWMsTUFBTTlJO29DQUMxQnlJLE9BQU9NLElBQUksQ0FBQyxPQUFNdlAsZUFBZXNQLFlBQVloQixTQUFTLEVBQUVGLG1CQUFtQm9CLFVBQVU7b0NBQ3JGVCxRQUFRO3dDQUNKQyxRQUFRO3dDQUNSM0csc0JBQXNCK0YsbUJBQW1CRSxTQUFTO3dDQUNsRHhFLGdCQUFnQndGLFlBQVlFLFVBQVU7b0NBQzFDO29DQUNBO2dDQUNKO2dDQUNBLE1BQU10SyxlQUFlLE1BQU0wRSxjQUFjMkcsZ0JBQWdCeEIsTUFBTTFHLG9CQUFvQixFQUFFMEcsTUFBTWpGLGNBQWM7Z0NBQ3pHLE1BQU00RywwQkFBMEJILGVBQWVsTSxLQUFLLENBQUNVO2dDQUNyRCxNQUFNNEwsb0JBQW9CRCx3QkFBd0IvUCxVQUFVLEtBQUssSUFDM0QsTUFBTSxDQUFDLElBQU1sRCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO3dDQUMzQyxNQUFNMEgsdUJBQXVCdUwsd0JBQXdCck0sS0FBSyxDQUFDLEdBQUdFO3dDQUM5RCxNQUFNRSxpQkFBaUIrSSwrQkFBK0JySTt3Q0FDdEQsSUFBSVYsbUJBQW9CcUssaUNBQWlDLEdBQUk7NENBQ3pELE1BQU0sSUFBSXJTLE1BQU07d0NBQ3BCO3dDQUNBcVMsaUNBQWlDcks7d0NBQ2pDLE9BQU9pRyxrQkFBa0JnRyx5QkFBeUJ4TDtvQ0FDdEQsRUFBQyxNQUFPO29DQUFFMkYsa0JBQWtCO2dDQUFTO2dDQUN6Q2tFLFFBQVE7b0NBQUVDLFFBQVE7b0NBQWE5SjtvQ0FBY3lMO2dDQUFrQjtnQ0FDL0QsTUFBTUMsU0FBU3pQLHdCQUF3QndQLGtCQUFrQjlGLGdCQUFnQixFQUFFLENBQUNsSixRQUFRQyxTQUFXbkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRzt3Q0FDM0gsTUFBTThMLEtBQUtzRjt3Q0FDWEksT0FBT00sSUFBSSxDQUFDLE9BQU1wRyxzQkFBc0I7NENBQ3BDSTs0Q0FDQXNILFNBQVM7NENBQ1RsUDs0Q0FDQUMsUUFBUUEsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSUEsU0FBUyxDQUFDO3dDQUM3RCxHQUFHc0QsYUFBWTt3Q0FDZixPQUFPLElBQUlqSCxRQUFRLENBQUNELFNBQVNFOzRDQUN6QmdSLHVCQUF1QixDQUFDM0YsR0FBRyxHQUFHO2dEQUMxQnZMLFNBQVFRLE1BQU07b0RBQ1YsT0FBUW1EO3dEQUNKLEtBQUs7d0RBQ0wsS0FBSzs0REFBZTtnRUFDaEIsTUFBTSxFQUFFbVAsZUFBZSxFQUFFLEdBQUd0UztnRUFDNUIsSUFBSXNTLG1CQUFtQixNQUFNO29FQUN6QixJQUFJO3dFQUNBeEQsZ0NBQWdDd0Q7b0VBQ3BDLEVBQ0EsT0FBT3hTLEdBQUc7d0VBQ05KLE9BQU9JO3dFQUNQO29FQUNKO2dFQUNKO2dFQUNBOzREQUNKO29EQUNKO29EQUNBTixRQUFRUTtnREFDWjtnREFDQU47NENBQ0o7d0NBQ0o7b0NBQ0o7Z0NBQ0EsSUFBSTtvQ0FDQUYsUUFBUSxPQUFNa1EsU0FBUzBDLE9BQU07Z0NBQ2pDLEVBQ0EsT0FBT3RTLEdBQUc7b0NBQ05KLE9BQU9JO2dDQUNYLFNBQ1E7b0NBQ0p3UjtvQ0FDQWIsT0FBTzhCLEtBQUs7Z0NBQ2hCO2dDQUNBOzRCQUNKO29CQUNKO2dCQUNKO1lBQ0EsSUFBSWpCO1lBQ0osSUFBSU07WUFDSixNQUFNQywwQkFBMEI7Z0JBQzVCLElBQUlQLGVBQWU7b0JBQ2ZBO2dCQUNKO2dCQUNBZixRQUFRO29CQUFFQyxRQUFRO29CQUFjWjtnQkFBbUI7Z0JBQ25ELElBQUlLLHdCQUF3QnRJLFdBQVc7b0JBQ25Dc0ksc0JBQXNCd0IsS0FBS0MsR0FBRztnQkFDbEM7Z0JBQ0FqQixTQUFTLElBQUkrQixVQUFVeEMsY0FBYztvQkFBQ3RCO2lCQUEwQjtnQkFDaEUrQixPQUFPcEQsZ0JBQWdCLENBQUMsUUFBUXNEO2dCQUNoQ0YsT0FBT3BELGdCQUFnQixDQUFDLFNBQVM0RDtnQkFDakNSLE9BQU9wRCxnQkFBZ0IsQ0FBQyxTQUFTa0U7Z0JBQ2pDZCxPQUFPcEQsZ0JBQWdCLENBQUMsV0FBV3lFO2dCQUNuQ1IsZ0JBQWdCO29CQUNaaFIsT0FBTzJNLFlBQVksQ0FBQzJFO29CQUNwQm5CLE9BQU90RCxtQkFBbUIsQ0FBQyxRQUFRd0Q7b0JBQ25DRixPQUFPdEQsbUJBQW1CLENBQUMsU0FBUzhEO29CQUNwQ1IsT0FBT3RELG1CQUFtQixDQUFDLFNBQVNvRTtvQkFDcENkLE9BQU90RCxtQkFBbUIsQ0FBQyxXQUFXMkU7Z0JBQzFDO1lBQ0o7WUFDQUQ7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTWSxlQUFlL0MsUUFBUSxFQUFFQyxNQUFNO0lBQ3BDLE9BQU8xUSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE9BQU95VCxvQkFBb0IvQyxRQUFRelAsSUFBSSxDQUFDLENBQUN5UztZQUNyQyxPQUFPO2dCQUNIekUsZ0JBQWdCeUUsU0FBU3pFLGNBQWM7Z0JBQ3ZDbE8sUUFBUTJTLFNBQVNQLE1BQU0sQ0FBQ2xTLElBQUksQ0FBQyxDQUFDa1M7b0JBQzFCLE9BQU8xQyxTQUFTLElBQUk1TSxNQUFNc1AsUUFBUTt3QkFDOUJyUCxLQUFJQyxNQUFNLEVBQUVDLENBQUM7NEJBQ1QsSUFBSUEsS0FBSyxvQkFBb0I7Z0NBQ3pCLE9BQU87b0NBQ0gsT0FBT2hFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7d0NBQ25DMFQsU0FBU0osS0FBSzt3Q0FDZDtvQ0FDSjtnQ0FDSjs0QkFDSixPQUVJLE9BQU92UCxNQUFNLENBQUNDLEVBQUU7d0JBQ3hCO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTeVAsb0JBQW9CL0MsTUFBTTtJQUMvQixPQUFPMVEsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQzJQO1FBQ0EsTUFBTWdCLHFCQUFxQixNQUFNL0g7UUFDakMsTUFBTW1JLGVBQWUsQ0FBQyxNQUFNLEVBQUVMLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPaUQsbUJBQW1CLENBQUMsUUFBUSxDQUFDO1FBQ2xILElBQUkzQztRQUNKLE1BQU1DLHNCQUFzQixDQUFDO1lBQ3pCLE1BQU1DLFdBQVc7bUJBQUk1Qiw0QkFBNEJDLG9CQUFvQjthQUFDO1lBQ3RFLE9BQU8sSUFBTzJCLFNBQVNySyxNQUFNLEdBQUcsSUFBSXFLLFNBQVNDLEtBQUssS0FBS0QsUUFBUSxDQUFDLEVBQUU7UUFDdEU7UUFDQSxJQUFJRSx1QkFBdUI7UUFDM0IsSUFBSUMsaUNBQWlDO1FBQ3JDLElBQUl1QztRQUNKLElBQUl0QyxRQUFRO1lBQUVDLFFBQVE7UUFBZTtRQUNyQyxJQUFJQztRQUNKLElBQUlhO1FBQ0osSUFBSXdCLGNBQWMsQ0FBQzVCLE1BQVFqUyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUN2RCxJQUFJNFQsWUFBWSxVQUFVO29CQUN0QixNQUFNeFUsVUFBVSxNQUFNNlMsSUFBSTVTLElBQUk7b0JBQzlCLE9BQU8wQyxhQUFhM0MsU0FBUzZKLE1BQU07Z0JBQ3ZDLE9BQ0s7b0JBQ0QsT0FBTyxNQUFNZ0osSUFBSTVTLElBQUksQ0FBQzBULFdBQVc7Z0JBQ3JDO1lBQ0o7UUFDQSw2QkFBNkI7UUFDN0IsMEVBQTBFO1FBQzFFLHFFQUFxRTtRQUNyRSxNQUFNOUQsaUJBQWlCLE1BQU0sSUFBSXpPLFFBQVEsQ0FBQ0QsU0FBU0U7WUFDL0MsTUFBTWlSLGFBQWEsSUFBTTFSLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQ3JELElBQUlzUixNQUFNQyxNQUFNLEtBQUssY0FBYzt3QkFDL0JJLFFBQVFDLElBQUksQ0FBQyxrRkFDVCxDQUFDLE1BQU0sRUFBRU4sTUFBTUMsTUFBTSxDQUFDLEdBQUcsQ0FBQzt3QkFDOUI7b0JBQ0o7b0JBQ0EsSUFBSUMsT0FBT2pILFFBQVEsQ0FBQzVFLFFBQVEsQ0FBQytKLDRCQUE0Qjt3QkFDckRrRSxXQUFXO29CQUNmLE9BQ0s7d0JBQ0RBLFdBQVc7b0JBQ2Y7b0JBQ0FwQyxPQUFPdEQsbUJBQW1CLENBQUMsUUFBUXdEO2dCQUN2QztZQUNBLE1BQU1NLGNBQWMsQ0FBQ0M7Z0JBQ2pCLElBQUlBLElBQUlDLFFBQVEsRUFBRTtvQkFDZFosUUFBUTt3QkFBRUMsUUFBUTtvQkFBZTtnQkFDckMsT0FDSztvQkFDRDlRLE9BQU8sSUFBSTFCLCtCQUErQlYsbUNBQW1DSyxvQkFBb0IsRUFBRSxDQUFDLHlDQUF5QyxFQUFFdVQsSUFBSTlTLElBQUksQ0FBQyxFQUFFLEVBQUU4UyxJQUFJRSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7d0JBQUVDLFlBQVlIO29CQUFJO2dCQUNsTTtnQkFDQUk7WUFDSjtZQUNBLE1BQU1DLGNBQWMsQ0FBQ0MsT0FBU3ZTLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQzFEcVM7b0JBQ0EsSUFBSUcsS0FBS0MsR0FBRyxLQUFLekIsdUJBQXVCMUIsNEJBQTRCRSxTQUFTLEVBQUU7d0JBQzNFL08sT0FBTyxJQUFJMUIsK0JBQStCVixtQ0FBbUNNLHFCQUFxQixFQUFFLENBQUMsNkNBQTZDLEVBQUVvUyxhQUFhLENBQUMsQ0FBQztvQkFDdkssT0FDSzt3QkFDRCxNQUFNLElBQUl2USxRQUFRLENBQUNEOzRCQUNmLE1BQU1tUyxlQUFlekI7NEJBQ3JCMEIscUJBQXFCdFIsT0FBT2dOLFVBQVUsQ0FBQzlOLFNBQVNtUzt3QkFDcEQ7d0JBQ0FFO29CQUNKO2dCQUNKO1lBQ0EsTUFBTWtCLDJCQUEyQixDQUFDN0IsTUFBUWpTLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQ3RFLE1BQU04UyxpQkFBaUIsTUFBTWUsWUFBWTVCO29CQUN6QyxJQUFJWCxNQUFNQyxNQUFNLEtBQUssY0FBYzt3QkFDL0IsSUFBSXVCLGVBQWU1UCxVQUFVLElBQUksR0FBRzs0QkFDaEMsTUFBTSxJQUFJbEUsTUFBTTt3QkFDcEI7d0JBQ0EsTUFBTXlNLGNBQWM4RSw0QkFBNEJ1Qzt3QkFDaER4QixRQUFROzRCQUNKQyxRQUFROzRCQUNSOUYsYUFBYUE7d0JBQ2pCO3dCQUNBLE1BQU13RCxpQkFBaUIsTUFBTTFELG1DQUFtQ29GLG1CQUFtQkUsU0FBUyxFQUFFSCxPQUFPaUQsbUJBQW1CLEVBQUVsSSxhQUFhaUYsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU9JLE9BQU87d0JBQ3JNVSxPQUFPdEQsbUJBQW1CLENBQUMsV0FBVzRGO3dCQUN0Q3ZULFFBQVEwTztvQkFDWjtnQkFDSjtZQUNBLElBQUkwRDtZQUNKLE1BQU1DLDBCQUEwQjtnQkFDNUIsSUFBSVAsZUFBZTtvQkFDZkE7Z0JBQ0o7Z0JBQ0FmLFFBQVE7b0JBQUVDLFFBQVE7b0JBQWNaO2dCQUFtQjtnQkFDbkQsSUFBSUssd0JBQXdCdEksV0FBVztvQkFDbkNzSSxzQkFBc0J3QixLQUFLQyxHQUFHO2dCQUNsQztnQkFDQWpCLFNBQVMsSUFBSStCLFVBQVV4QyxjQUFjO29CQUFDdEI7b0JBQTJCQztpQkFBMEI7Z0JBQzNGOEIsT0FBT3BELGdCQUFnQixDQUFDLFFBQVFzRDtnQkFDaENGLE9BQU9wRCxnQkFBZ0IsQ0FBQyxTQUFTNEQ7Z0JBQ2pDUixPQUFPcEQsZ0JBQWdCLENBQUMsU0FBU2tFO2dCQUNqQ2QsT0FBT3BELGdCQUFnQixDQUFDLFdBQVcwRjtnQkFDbkN6QixnQkFBZ0I7b0JBQ1poUixPQUFPMk0sWUFBWSxDQUFDMkU7b0JBQ3BCbkIsT0FBT3RELG1CQUFtQixDQUFDLFFBQVF3RDtvQkFDbkNGLE9BQU90RCxtQkFBbUIsQ0FBQyxTQUFTOEQ7b0JBQ3BDUixPQUFPdEQsbUJBQW1CLENBQUMsU0FBU29FO29CQUNwQ2QsT0FBT3RELG1CQUFtQixDQUFDLFdBQVc0RjtnQkFDMUM7WUFDSjtZQUNBbEI7UUFDSjtRQUNBLDBCQUEwQjtRQUMxQixvRkFBb0Y7UUFDcEYsZ0ZBQWdGO1FBQ2hGLElBQUltQixxQkFBcUI7UUFDekIsSUFBSS9CO1FBQ0osT0FBTztZQUFFL0M7WUFBZ0JxRSxPQUFPO2dCQUN4QjlCLE9BQU84QixLQUFLO2dCQUNadEI7WUFDSjtZQUFHbUIsUUFBUSxJQUFJM1MsUUFBUSxDQUFDRCxTQUFTRTtnQkFDN0IsOERBQThEO2dCQUM5RCxNQUFNZ1IsMEJBQTBCLENBQUM7Z0JBQ2pDLE1BQU1vQixnQkFBZ0IsQ0FBQ1osTUFBUWpTLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7d0JBQzNELE1BQU04UyxpQkFBaUIsTUFBTWUsWUFBWTVCO3dCQUN6QyxPQUFRWCxNQUFNQyxNQUFNOzRCQUNoQixLQUFLO2dDQUNELElBQUl1QixlQUFlNVAsVUFBVSxLQUFLLEdBQUc7b0NBQ2pDLE1BQU0sSUFBSWxFLE1BQU07Z0NBQ3BCO2dDQUNBLE1BQU02UyxjQUFjLE1BQU05STtnQ0FDMUIsTUFBTWlMLFlBQVksTUFBTXpSLGVBQWVzUCxZQUFZaEIsU0FBUyxFQUFFRixtQkFBbUJvQixVQUFVO2dDQUMzRixJQUFJNkIsWUFBWSxVQUFVO29DQUN0QnBDLE9BQU9NLElBQUksQ0FBQ3ZRLGVBQWV5UztnQ0FDL0IsT0FDSztvQ0FDRHhDLE9BQU9NLElBQUksQ0FBQ2tDO2dDQUNoQjtnQ0FDQTFDLFFBQVE7b0NBQ0pDLFFBQVE7b0NBQ1IzRyxzQkFBc0IrRixtQkFBbUJFLFNBQVM7b0NBQ2xEeEUsZ0JBQWdCd0YsWUFBWUUsVUFBVTtnQ0FDMUM7Z0NBQ0E7NEJBQ0osS0FBSztnQ0FDRCxJQUFJO29DQUNBLE1BQU1ySyx1QkFBdUJvTCxlQUFlbE0sS0FBSyxDQUFDLEdBQUdFO29DQUNyRCxNQUFNRSxpQkFBaUIrSSwrQkFBK0JySTtvQ0FDdEQsSUFBSVYsbUJBQW9CcUssaUNBQWlDLEdBQUk7d0NBQ3pELE1BQU0sSUFBSXJTLE1BQU07b0NBQ3BCO29DQUNBcVMsaUNBQWlDcks7b0NBQ2pDLE1BQU0yRSxpQkFBaUIsTUFBTUksc0JBQXNCK0csZ0JBQWdCeEIsTUFBTTdKLFlBQVk7b0NBQ3JGLE1BQU11TCxrQkFBa0J2Qix1QkFBdUIsQ0FBQzlGLGVBQWVHLEVBQUUsQ0FBQztvQ0FDbEUsT0FBTzJGLHVCQUF1QixDQUFDOUYsZUFBZUcsRUFBRSxDQUFDO29DQUNqRGtILGdCQUFnQnpTLE9BQU8sQ0FBQ29MLGVBQWU1SyxNQUFNO2dDQUNqRCxFQUNBLE9BQU9GLEdBQUc7b0NBQ04sSUFBSUEsYUFBYWYsd0NBQXdDO3dDQUNyRCxNQUFNa1Qsa0JBQWtCdkIsdUJBQXVCLENBQUM1USxFQUFFZCxnQkFBZ0IsQ0FBQzt3Q0FDbkUsT0FBTzBSLHVCQUF1QixDQUFDNVEsRUFBRWQsZ0JBQWdCLENBQUM7d0NBQ2xEaVQsZ0JBQWdCdlMsTUFBTSxDQUFDSTtvQ0FDM0IsT0FDSzt3Q0FDRCxNQUFNQTtvQ0FDVjtnQ0FDSjtnQ0FDQTs0QkFDSixLQUFLO2dDQUFrQjtvQ0FDbkIsTUFBTTRHLGVBQWUsTUFBTTBFLGNBQWMyRyxnQkFBZ0J4QixNQUFNMUcsb0JBQW9CLEVBQUUwRyxNQUFNakYsY0FBYztvQ0FDekcsTUFBTTRHLDBCQUEwQkgsZUFBZWxNLEtBQUssQ0FBQ1U7b0NBQ3JELE1BQU00TCxvQkFBb0JELHdCQUF3Qi9QLFVBQVUsS0FBSyxJQUMzRCxNQUFNLENBQUMsSUFBTWxELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7NENBQzNDLE1BQU0wSCx1QkFBdUJ1TCx3QkFBd0JyTSxLQUFLLENBQUMsR0FBR0U7NENBQzlELE1BQU1FLGlCQUFpQitJLCtCQUErQnJJOzRDQUN0RCxJQUFJVixtQkFBb0JxSyxpQ0FBaUMsR0FBSTtnREFDekQsTUFBTSxJQUFJclMsTUFBTTs0Q0FDcEI7NENBQ0FxUyxpQ0FBaUNySzs0Q0FDakMsT0FBT2lHLGtCQUFrQmdHLHlCQUF5QnhMO3dDQUN0RCxFQUFDLE1BQU87d0NBQUUyRixrQkFBa0I7b0NBQVM7b0NBQ3pDa0UsUUFBUTt3Q0FBRUMsUUFBUTt3Q0FBYTlKO3dDQUFjeUw7b0NBQWtCO29DQUMvRCxNQUFNQyxTQUFTelAsd0JBQXdCd1Asa0JBQWtCOUYsZ0JBQWdCLEVBQUUsQ0FBQ2xKLFFBQVFDLFNBQVduRSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHOzRDQUMzSCxNQUFNOEwsS0FBS3NGOzRDQUNYLE1BQU00QyxZQUFZLE1BQU10SSxzQkFBc0I7Z0RBQzFDSTtnREFDQXNILFNBQVM7Z0RBQ1RsUDtnREFDQUMsUUFBUUEsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSUEsU0FBUyxDQUFDOzRDQUM3RCxHQUFHc0Q7NENBQ0gsSUFBSW1NLFlBQVksVUFBVTtnREFDdEJwQyxPQUFPTSxJQUFJLENBQUN2USxlQUFleVM7NENBQy9CLE9BQ0s7Z0RBQ0R4QyxPQUFPTSxJQUFJLENBQUNrQzs0Q0FDaEI7NENBQ0EsT0FBTyxJQUFJeFQsUUFBUSxDQUFDRCxTQUFTRTtnREFDekJnUix1QkFBdUIsQ0FBQzNGLEdBQUcsR0FBRztvREFDMUJ2TCxTQUFRUSxNQUFNO3dEQUNWLE9BQVFtRDs0REFDSixLQUFLOzREQUNMLEtBQUs7Z0VBQWU7b0VBQ2hCLE1BQU0sRUFBRW1QLGVBQWUsRUFBRSxHQUFHdFM7b0VBQzVCLElBQUlzUyxtQkFBbUIsTUFBTTt3RUFDekIsSUFBSTs0RUFDQXhELGdDQUFnQ3dEO3dFQUNwQyxFQUNBLE9BQU94UyxHQUFHOzRFQUNOSixPQUFPSTs0RUFDUDt3RUFDSjtvRUFDSjtvRUFDQTtnRUFDSjt3REFDSjt3REFDQU4sUUFBUVE7b0RBQ1o7b0RBQ0FOO2dEQUNKOzRDQUNKO3dDQUNKO29DQUNBc1QscUJBQXFCO29DQUNyQixJQUFJO3dDQUNBeFQsUUFBUTRTO29DQUNaLEVBQ0EsT0FBT3RTLEdBQUc7d0NBQ05KLE9BQU9JO29DQUNYO29DQUNBO2dDQUNKO3dCQUNKO29CQUNKO2dCQUNBMlEsT0FBT3BELGdCQUFnQixDQUFDLFdBQVd5RTtnQkFDbkNiLGNBQWM7b0JBQ1ZSLE9BQU90RCxtQkFBbUIsQ0FBQyxXQUFXMkU7b0JBQ3RDUjtvQkFDQSxJQUFJLENBQUMwQixvQkFBb0I7d0JBQ3JCdFQsT0FBTyxJQUFJMUIsK0JBQStCVixtQ0FBbUNLLG9CQUFvQixFQUFFLENBQUMsZ0RBQWdELENBQUMsRUFBRTs0QkFBRTBULFlBQVksSUFBSTZCLFdBQVc7d0JBQXVDO29CQUMvTjtnQkFDSjtZQUNKO1FBQUc7SUFDWDtBQUNKO0FBRTJSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWNwLWNvaW4vLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sLXdlYjNqcy9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanM/NDk4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwnO1xuXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlID0ge1xuICAgIEVSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFOiAnRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0UnLFxuICAgIEVSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0U6ICdFUlJPUl9SRUZMRUNUT1JfSURfT1VUX09GX1JBTkdFJyxcbiAgICBFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMOiAnRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCcsXG4gICAgRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQ6ICdFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9DTE9TRUQ6ICdFUlJPUl9TRVNTSU9OX0NMT1NFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9USU1FT1VUOiAnRVJST1JfU0VTU0lPTl9USU1FT1VUJyxcbiAgICBFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EOiAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcsXG4gICAgRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OOiAnRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OJyxcbiAgICBFUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQ6ICdFUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQnLFxufTtcbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IFtjb2RlLCBtZXNzYWdlLCBkYXRhXSA9IGFyZ3M7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJztcbiAgICB9XG59XG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUgPSB7XG4gICAgLy8gS2VlcCB0aGVzZSBpbiBzeW5jIHdpdGggYG1vYmlsZXdhbGxldGFkYXB0ZXIvY29tbW9uL1Byb3RvY29sQ29udHJhY3QuamF2YWAuXG4gICAgRVJST1JfQVVUSE9SSVpBVElPTl9GQUlMRUQ6IC0xLFxuICAgIEVSUk9SX0lOVkFMSURfUEFZTE9BRFM6IC0yLFxuICAgIEVSUk9SX05PVF9TSUdORUQ6IC0zLFxuICAgIEVSUk9SX05PVF9TVUJNSVRURUQ6IC00LFxuICAgIEVSUk9SX1RPT19NQU5ZX1BBWUxPQURTOiAtNSxcbiAgICBFUlJPUl9BVFRFU1RfT1JJR0lOX0FORFJPSUQ6IC0xMDAsXG59O1xuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbanNvblJwY01lc3NhZ2VJZCwgY29kZSwgbWVzc2FnZSwgZGF0YV0gPSBhcmdzO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5qc29uUnBjTWVzc2FnZUlkID0ganNvblJwY01lc3NhZ2VJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yJztcbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoaW5wdXQpO1xufVxuZnVuY3Rpb24gZnJvbVVpbnQ4QXJyYXkoYnl0ZUFycmF5LCB1cmxzYWZlKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5jYWxsKG51bGwsIC4uLmJ5dGVBcnJheSkpO1xuICAgIGlmICh1cmxzYWZlKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPSskLywgJycpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG59XG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3aW5kb3dcbiAgICAgICAgLmF0b2IoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSlcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGVsbG9SZXEoZWNkaFB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleUJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBlY2RoUHVibGljS2V5KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5zaWduKHsgaGFzaDogJ1NIQS0yNTYnLCBuYW1lOiAnRUNEU0EnIH0sIGFzc29jaWF0aW9uS2V5cGFpclByaXZhdGVLZXksIHB1YmxpY0tleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyLmJ5dGVMZW5ndGggKyBzaWduYXR1cmVCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShwdWJsaWNLZXlCdWZmZXIpLCAwKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJ1ZmZlciksIHB1YmxpY0tleUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTSVdTTWVzc2FnZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0KHBheWxvYWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQocGF5bG9hZCkge1xuICAgIHJldHVybiBlbmNvZGUoY3JlYXRlU0lXU01lc3NhZ2UocGF5bG9hZCkpO1xufVxuXG4vLyBvcHRpb25hbCBmZWF0dXJlc1xuY29uc3QgU29sYW5hU2lnblRyYW5zYWN0aW9ucyA9ICdzb2xhbmE6c2lnblRyYW5zYWN0aW9ucyc7XG5jb25zdCBTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24gPSAnc29sYW5hOmNsb25lQXV0aG9yaXphdGlvbic7XG5jb25zdCBTb2xhbmFTaWduSW5XaXRoU29sYW5hID0gJ3NvbGFuYTpzaWduSW5XaXRoU29sYW5hJztcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHkgdGhhdCBoYW5kbGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZCBBUEkgdG8gUlBDIGNvbnZlcnNpb24uXG4gKlxuICogQHBhcmFtIHByb3RvY29sVmVyc2lvbiB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiB1c2UgZm9yIHRoaXMgc2Vzc2lvbi9yZXF1ZXN0XG4gKiBAcGFyYW0gcHJvdG9jb2xSZXF1ZXN0SGFuZGxlciBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgc2VuZGluZyB0aGUgUlBDIHJlcXVlc3QgdG8gdGhlIHdhbGxldCBlbmRwb2ludC5cbiAqIEByZXR1cm5zIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkocHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICAvLyBXcmFwcGluZyBhIFByb3h5IGluIGEgcHJvbWlzZSByZXN1bHRzIGluIHRoZSBQcm94eSBiZWluZyBhc2tlZCBmb3IgYSAndGhlbicgcHJvcGVydHkgc28gbXVzdCBcbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsIGlmICd0aGVuJyBpcyBjYWxsZWQgb24gdGhpcyBwcm94eSB0byBsZXQgdGhlICdyZXNvbHZlKCknIGNhbGwga25vdyB0aGlzIGlzIG5vdCBhIHByb21pc2UuXG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mzg5MDkwNFxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAocCA9PT0gJ3RoZW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoaW5wdXRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IGhhbmRsZU1vYmlsZVdhbGxldFJlcXVlc3QocCwgaW5wdXRQYXJhbXMsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHRyaWVkIHRvIHNpZ24gaW4gYnV0IHRoZSB3YWxsZXQgZGlkIG5vdCByZXR1cm4gYSBzaWduIGluIHJlc3VsdCwgZmFsbGJhY2sgb24gbWVzc2FnZSBzaWduaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnYXV0aG9yaXplJyAmJiBwYXJhbXMuc2lnbl9pbl9wYXlsb2FkICYmICFyZXN1bHQuc2lnbl9pbl9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3NpZ25faW5fcmVzdWx0J10gPSB5aWVsZCBzaWduSW5GYWxsYmFjayhwYXJhbXMuc2lnbl9pbl9wYXlsb2FkLCByZXN1bHQsIHByb3RvY29sUmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKHAsIHJlc3VsdCwgcHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlcXVlc3RzIGFuZCBkZXRlcm1pbmVzIHRoZSBjb3JyZWN0IE1XQSBSUEMgbWV0aG9kIGFuZCBwYXJhbXMgdG8gY2FsbC5cbiAqIFRoaXMgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmFzZWQgb24gdGhlIHByb3ZpZGVkIEBwcm90b2NvbFZlcnNpb24uXG4gKlxuICogQHBhcmFtIG1ldGhvZE5hbWUgdGhlIG5hbWUgb2Yge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIG1ldGhvZFBhcmFtcyB0aGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIFJQQyByZXF1ZXN0IG1ldGhvZCBhbmQgcGFyYW1zIHRoYXQgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIHdhbGxldCBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KG1ldGhvZE5hbWUsIG1ldGhvZFBhcmFtcywgcHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgbGV0IHBhcmFtcyA9IG1ldGhvZFBhcmFtcztcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kTmFtZVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgKGxldHRlcikgPT4gYF8ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICBjYXNlICdhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBsZXQgeyBjaGFpbiB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTp0ZXN0bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAndGVzdG5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6ZGV2bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnZGV2bmV0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTptYWlubmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnbWFpbm5ldC1iZXRhJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gcGFyYW1zLmNsdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsdXN0ZXIgPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVzdG5ldCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gYHNvbGFuYToke2NoYWlufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYWlubmV0LWJldGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICdzb2xhbmE6bWFpbm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aF90b2tlbiwgaWRlbnRpdHkgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChhdXRoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHsgYXV0aF90b2tlbjogYXV0aF90b2tlbiwgaWRlbnRpdHk6IGlkZW50aXR5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSAnYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWV0aG9kLCBwYXJhbXMgfTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlc3BvbnNlcyBhbmQgbW9kaWZpZXMgdGhlIHJlc3BvbnNlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgaWYgbmVlZGVkXG4gKlxuICogQHBhcmFtIG1ldGhvZCB0aGUge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIHJlc3BvbnNlIHRoZSBvcmlnaW5hbCByZXNwb25zZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIHBvc3NpYmx5IG1vZGlmaWVkIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKG1ldGhvZCwgcmVzcG9uc2UsIHByb3RvY29sVmVyc2lvbikge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ2dldENhcGFiaWxpdGllcyc6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWdhY3knOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gW1NvbGFuYVNpZ25UcmFuc2FjdGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IGZlYXR1cmVzOiBmZWF0dXJlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndjEnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhcGFiaWxpdGllcyksIHsgc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnM6IHRydWUsIHN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb246IGNhcGFiaWxpdGllcy5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBzaWduSW5GYWxsYmFjayhzaWduSW5QYXlsb2FkLCBhdXRob3JpemF0aW9uUmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IChfYSA9IHNpZ25JblBheWxvYWQuZG9tYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHNbMF0uYWRkcmVzcztcbiAgICAgICAgY29uc3Qgc2l3c01lc3NhZ2UgPSBjcmVhdGVTSVdTTWVzc2FnZUJhc2U2NChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNpZ25JblBheWxvYWQpLCB7IGRvbWFpbiwgYWRkcmVzcyB9KSk7XG4gICAgICAgIGNvbnN0IHNpZ25NZXNzYWdlUmVzdWx0ID0geWllbGQgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcignc2lnbl9tZXNzYWdlcycsIHtcbiAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NdLFxuICAgICAgICAgICAgcGF5bG9hZHM6IFtzaXdzTWVzc2FnZV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25JblJlc3VsdCA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZWRfbWVzc2FnZTogc2l3c01lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25NZXNzYWdlUmVzdWx0LnNpZ25lZF9wYXlsb2Fkc1swXS5zbGljZShzaXdzTWVzc2FnZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzaWduSW5SZXN1bHQ7XG4gICAgfSk7XG59XG5cbmNvbnN0IFNFUVVFTkNFX05VTUJFUl9CWVRFUyA9IDQ7XG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvcihzZXF1ZW5jZU51bWJlcikge1xuICAgIGlmIChzZXF1ZW5jZU51bWJlciA+PSA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0Ym91bmQgc2VxdWVuY2UgbnVtYmVyIG92ZXJmbG93LiBUaGUgbWF4aW11bSBzZXF1ZW5jZSBudW1iZXIgaXMgMzItYnl0ZXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBBcnJheUJ1ZmZlcihTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBzZXF1ZW5jZU51bWJlciwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KTtcbn1cblxuY29uc3QgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTID0gMTI7XG5jb25zdCBFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTID0gNjU7XG5mdW5jdGlvbiBlbmNyeXB0TWVzc2FnZShwbGFpbnRleHQsIHNlcXVlbmNlTnVtYmVyLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IGNyZWF0ZVNlcXVlbmNlTnVtYmVyVmVjdG9yKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBuZXcgVWludDhBcnJheShJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZW5jcnlwdChnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXJWZWN0b3IsIGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2hhcmVkU2VjcmV0LCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGxhaW50ZXh0KSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFVpbnQ4QXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCArIGluaXRpYWxpemF0aW9uVmVjdG9yLmJ5dGVMZW5ndGggKyBjaXBoZXJ0ZXh0LmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpLCAwKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KSwgc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCArIGluaXRpYWxpemF0aW9uVmVjdG9yLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IG1lc3NhZ2Uuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBtZXNzYWdlLnNsaWNlKFNFUVVFTkNFX05VTUJFUl9CWVRFUywgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTICsgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG1lc3NhZ2Uuc2xpY2UoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTICsgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0QnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlclZlY3RvciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzaGFyZWRTZWNyZXQsIGNpcGhlcnRleHQpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBnZXRVdGY4RGVjb2RlcigpLmRlY29kZShwbGFpbnRleHRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyLCBpbml0aWFsaXphdGlvblZlY3Rvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZGl0aW9uYWxEYXRhOiBzZXF1ZW5jZU51bWJlcixcbiAgICAgICAgaXY6IGluaXRpYWxpemF0aW9uVmVjdG9yLFxuICAgICAgICBuYW1lOiAnQUVTLUdDTScsXG4gICAgICAgIHRhZ0xlbmd0aDogMTI4LCAvLyAxNiBieXRlIHRhZyA9PiAxMjggYml0c1xuICAgIH07XG59XG5sZXQgX3V0ZjhEZWNvZGVyO1xuZnVuY3Rpb24gZ2V0VXRmOERlY29kZXIoKSB7XG4gICAgaWYgKF91dGY4RGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF91dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICB9XG4gICAgcmV0dXJuIF91dGY4RGVjb2Rlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0VDRFNBJyxcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ3NpZ24nXSAvKiBrZXlVc2FnZXMgKi8pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVDREhLZXlwYWlyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RIJyxcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2Rlcml2ZUtleScsICdkZXJpdmVCaXRzJ10gLyoga2V5VXNhZ2VzICovKTtcbiAgICB9KTtcbn1cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk0NTg5OTYvODAyMDQ3XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGJ1ZmZlcikge1xuICAgIGxldCBiaW5hcnkgPSAnJztcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2lpXSk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYnRvYShiaW5hcnkpO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21Bc3NvY2lhdGlvblBvcnQoKSB7XG4gICAgcmV0dXJuIGFzc2VydEFzc29jaWF0aW9uUG9ydCg0OTE1MiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg2NTUzNSAtIDQ5MTUyICsgMSkpKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzc29jaWF0aW9uUG9ydChwb3J0KSB7XG4gICAgaWYgKHBvcnQgPCA0OTE1MiB8fCBwb3J0ID4gNjU1MzUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFLCBgQXNzb2NpYXRpb24gcG9ydCBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuIDQ5MTUyIGFuZCA2NTUzNS4gJHtwb3J0fSBnaXZlbi5gLCB7IHBvcnQgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3J0O1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKHVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmcpIHtcbiAgICByZXR1cm4gdW5zYWZlQmFzZTY0RW5jb2RlZFN0cmluZy5yZXBsYWNlKC9bLys9XS9nLCAobSkgPT4gKHtcbiAgICAgICAgJy8nOiAnXycsXG4gICAgICAgICcrJzogJy0nLFxuICAgICAgICAnPSc6ICcuJyxcbiAgICB9W21dKSk7XG59XG5cbmNvbnN0IElOVEVOVF9OQU1FID0gJ3NvbGFuYS13YWxsZXQnO1xuZnVuY3Rpb24gZ2V0UGF0aFBhcnRzKHBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gKHBhdGhTdHJpbmdcbiAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICAucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCAnJylcbiAgICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIGRpcmVjdG9yaWVzXG4gICAgICAgIC5zcGxpdCgnLycpKTtcbn1cbmZ1bmN0aW9uIGdldEludGVudFVSTChtZXRob2RQYXRobmFtZSwgaW50ZW50VXJsQmFzZSkge1xuICAgIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgICBpZiAoaW50ZW50VXJsQmFzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFzZVVybCA9IG5ldyBVUkwoaW50ZW50VXJsQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICBpZiAoKGJhc2VVcmwgPT09IG51bGwgfHwgYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZVVybC5wcm90b2NvbCkgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFzZVVybCB8fCAoYmFzZVVybCA9IG5ldyBVUkwoYCR7SU5URU5UX05BTUV9Oi9gKSk7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBtZXRob2RQYXRobmFtZS5zdGFydHNXaXRoKCcvJylcbiAgICAgICAgPyAvLyBNZXRob2QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gUmVwbGFjZSBpdCB3aG9sZXNhbGUuXG4gICAgICAgICAgICBtZXRob2RQYXRobmFtZVxuICAgICAgICA6IC8vIE1ldGhvZCBpcyBhIHJlbGF0aXZlIHBhdGguIE1lcmdlIGl0IHdpdGggdGhlIGV4aXN0aW5nIG9uZS5cbiAgICAgICAgICAgIFsuLi5nZXRQYXRoUGFydHMoYmFzZVVybC5wYXRobmFtZSksIC4uLmdldFBhdGhQYXJ0cyhtZXRob2RQYXRobmFtZSldLmpvaW4oJy8nKTtcbiAgICByZXR1cm4gbmV3IFVSTChwYXRobmFtZSwgYmFzZVVybCk7XG59XG5mdW5jdGlvbiBnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCBwdXRhdGl2ZVBvcnQsIGFzc29jaWF0aW9uVVJMQmFzZSwgcHJvdG9jb2xWZXJzaW9ucyA9IFsndjEnXSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uUG9ydCA9IGFzc2VydEFzc29jaWF0aW9uUG9ydChwdXRhdGl2ZVBvcnQpO1xuICAgICAgICBjb25zdCBleHBvcnRlZEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBhc3NvY2lhdGlvblB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGV4cG9ydGVkS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gZ2V0SW50ZW50VVJMKCd2MS9hc3NvY2lhdGUvbG9jYWwnLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXNzb2NpYXRpb24nLCBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKGVuY29kZWRLZXkpKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BvcnQnLCBgJHthc3NvY2lhdGlvblBvcnR9YCk7XG4gICAgICAgIHByb3RvY29sVmVyc2lvbnMuZm9yRWFjaCgodmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3YnLCB2ZXJzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZW1vdGVBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCBob3N0QXV0aG9yaXR5LCByZWZsZWN0b3JJZCwgYXNzb2NpYXRpb25VUkxCYXNlLCBwcm90b2NvbFZlcnNpb25zID0gWyd2MSddKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBlbmNvZGVkS2V5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhleHBvcnRlZEtleSk7XG4gICAgICAgIGNvbnN0IHVybCA9IGdldEludGVudFVSTCgndjEvYXNzb2NpYXRlL3JlbW90ZScsIGFzc29jaWF0aW9uVVJMQmFzZSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhc3NvY2lhdGlvbicsIGdldFN0cmluZ1dpdGhVUkxVbnNhZmVDaGFyYWN0ZXJzUmVwbGFjZWQoZW5jb2RlZEtleSkpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncmVmbGVjdG9yJywgYCR7aG9zdEF1dGhvcml0eX1gKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2lkJywgYCR7ZnJvbVVpbnQ4QXJyYXkocmVmbGVjdG9ySWQsIHRydWUpfWApO1xuICAgICAgICBwcm90b2NvbFZlcnNpb25zLmZvckVhY2goKHZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2JywgdmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0SnNvblJwY01lc3NhZ2UoanNvblJwY01lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IEpTT04uc3RyaW5naWZ5KGpzb25ScGNNZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBqc29uUnBjTWVzc2FnZS5pZDtcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRNZXNzYWdlKHBsYWludGV4dCwgc2VxdWVuY2VOdW1iZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0SnNvblJwY01lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0geWllbGQgZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSBKU09OLnBhcnNlKHBsYWludGV4dCk7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUnBjTWVzc2FnZSwgJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcihqc29uUnBjTWVzc2FnZS5pZCwganNvblJwY01lc3NhZ2UuZXJyb3IuY29kZSwganNvblJwY01lc3NhZ2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25ScGNNZXNzYWdlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlbGxvUnNwKHBheWxvYWRCdWZmZXIsIC8vIFRoZSBYOS42Mi1lbmNvZGVkIHdhbGxldCBlbmRwb2ludCBlcGhlbWVyYWwgRUNESCBwdWJsaWMga2V5cG9pbnQuXG5hc3NvY2lhdGlvblB1YmxpY0tleSwgZWNkaFByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBbYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIsIHdhbGxldFB1YmxpY0tleV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpLFxuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHBheWxvYWRCdWZmZXIuc2xpY2UoMCwgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyksIHsgbmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbXSAvKiBrZXlVc2FnZXMgKi8pLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHsgbmFtZTogJ0VDREgnLCBwdWJsaWM6IHdhbGxldFB1YmxpY0tleSB9LCBlY2RoUHJpdmF0ZUtleSwgMjU2KTtcbiAgICAgICAgY29uc3QgZWNkaFNlY3JldEtleSA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBzaGFyZWRTZWNyZXQsICdIS0RGJywgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZGVyaXZlS2V5J10gLyoga2V5VXNhZ2VzICovKTtcbiAgICAgICAgY29uc3QgYWVzS2V5TWF0ZXJpYWxWYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgICAgICBzYWx0OiBuZXcgVWludDhBcnJheShhc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciksXG4gICAgICAgICAgICBpbmZvOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9LCBlY2RoU2VjcmV0S2V5LCB7IG5hbWU6ICdBRVMtR0NNJywgbGVuZ3RoOiAxMjggfSwgZmFsc2UgLyogZXh0cmFjdGFibGUgKi8sIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgICAgICByZXR1cm4gYWVzS2V5TWF0ZXJpYWxWYWw7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vzc2lvblByb3BzKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25Qcm9wZXJ0aWVzID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBsZXQgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChqc29uUHJvcGVydGllcywgJ3YnKSkge1xuICAgICAgICAgICAgc3dpdGNoIChqc29uUHJvcGVydGllcy52KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ3YxJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04sIGBVbmtub3duL3Vuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7anNvblByb3BlcnRpZXMudn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHByb3RvY29sX3ZlcnNpb246IHByb3RvY29sVmVyc2lvblxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgQnJvd3NlciA9IHtcbiAgICBGaXJlZm94OiAwLFxuICAgIE90aGVyOiAxLFxufTtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveC8nKSAhPT0gLTEgPyBCcm93c2VyLkZpcmVmb3ggOiBCcm93c2VyLk90aGVyO1xufVxuZnVuY3Rpb24gZ2V0RGV0ZWN0aW9uUHJvbWlzZSgpIHtcbiAgICAvLyBDaHJvbWUgYW5kIG90aGVycyBzaWxlbnRseSBmYWlsIGlmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgLy8gRm9yIHRoZXNlLCB3ZSB3YWl0IHRvIHNlZSBpZiB0aGUgYnJvd3NlciBpcyBuYXZpZ2F0ZWQgYXdheSBmcm9tIGluXG4gICAgLy8gYSByZWFzb25hYmxlIGFtb3VudCBvZiB0aW1lIChpZS4gdGhlIG5hdGl2ZSB3YWxsZXQgb3BlbmVkKS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgfSk7XG59XG5sZXQgX2ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIGxhdW5jaFVybFRocm91Z2hIaWRkZW5GcmFtZSh1cmwpIHtcbiAgICBpZiAoX2ZyYW1lID09IG51bGwpIHtcbiAgICAgICAgX2ZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIF9mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9mcmFtZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgX2ZyYW1lLmNvbnRlbnRXaW5kb3cubG9jYXRpb24uaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoYXNzb2NpYXRpb25VcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGlzIGFuIEFuZHJvaWQgJ0FwcCBMaW5rJyBvciBpT1MgJ1VuaXZlcnNhbCBMaW5rJy5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZWd1bGFyIHdlYiBVUkxzIHRoYXQgYXJlIGRlc2lnbmVkIHRvIGxhdW5jaCBhbiBhcHAgaWYgaXRcbiAgICAgICAgICAgIC8vIGlzIGluc3RhbGxlZCBvciBsb2FkIHRoZSBhY3R1YWwgdGFyZ2V0IHdlYnBhZ2UgaWYgbm90LlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhc3NvY2lhdGlvblVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNzb2NpYXRpb24gVVJMIGhhcyBhIGN1c3RvbSBwcm90b2NvbCAoZWcuIGBzb2xhbmEtd2FsbGV0OmApXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChicm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5GaXJlZm94OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBjdXN0b20gcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94LCBpdCB0aHJvd3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGlzIGxpbmUsIGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQnJvd3Nlci5PdGhlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0aW9uUHJvbWlzZSA9IGdldERldGVjdGlvblByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZGV0ZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShicm93c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9XQUxMRVRfTk9UX0ZPVU5ELCAnRm91bmQgbm8gaW5zdGFsbGVkIHdhbGxldCB0aGF0IHN1cHBvcnRzIHRoZSBtb2JpbGUgd2FsbGV0IHByb3RvY29sLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25QdWJsaWNLZXksIGFzc29jaWF0aW9uVVJMQmFzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUFzc29jaWF0aW9uUG9ydCA9IGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIHJhbmRvbUFzc29jaWF0aW9uUG9ydCwgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgeWllbGQgbGF1bmNoQXNzb2NpYXRpb24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICByZXR1cm4gcmFuZG9tQXNzb2NpYXRpb25Qb3J0O1xuICAgIH0pO1xufVxuXG5jb25zdCBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcgPSB7XG4gICAgLyoqXG4gICAgICogMzAwIG1pbGxpc2Vjb25kcyBpcyBhIGdlbmVyYWxseSBhY2NlcHRlZCB0aHJlc2hvbGQgZm9yIHdoYXQgc29tZW9uZVxuICAgICAqIHdvdWxkIGNvbnNpZGVyIGFuIGFjY2VwdGFibGUgcmVzcG9uc2UgdGltZSBmb3IgYSB1c2VyIGludGVyZmFjZVxuICAgICAqIGFmdGVyIGhhdmluZyBwZXJmb3JtZWQgYSBsb3ctYXR0ZW50aW9uIHRhcHBpbmcgdGFzay4gV2Ugc2V0IHRoZSBpbml0aWFsXG4gICAgICogaW50ZXJ2YWwgYXQgd2hpY2ggd2Ugd2FpdCBmb3IgdGhlIHdhbGxldCB0byBzZXQgdXAgdGhlIHdlYnNvY2tldCBhdFxuICAgICAqIGhhbGYgdGhpcywgYXMgcGVyIHRoZSBOeXF1aXN0IGZyZXF1ZW5jeSwgd2l0aCBhIHByb2dyZXNzaXZlIGJhY2tvZmZcbiAgICAgKiBzZXF1ZW5jZSBmcm9tIHRoZXJlLiBUaGUgdG90YWwgd2FpdCB0aW1lIGlzIDMwcywgd2hpY2ggYWxsb3dzIGZvciB0aGVcbiAgICAgKiB1c2VyIHRvIGJlIHByZXNlbnRlZCB3aXRoIGEgZGlzYW1iaWd1YXRpb24gZGlhbG9nLCBzZWxlY3QgYSB3YWxsZXQsIGFuZFxuICAgICAqIGZvciB0aGUgd2FsbGV0IGFwcCB0byBzdWJzZXF1ZW50bHkgc3RhcnQuXG4gICAgICovXG4gICAgcmV0cnlEZWxheVNjaGVkdWxlTXM6IFsxNTAsIDE1MCwgMjAwLCA1MDAsIDUwMCwgNzUwLCA3NTAsIDEwMDBdLFxuICAgIHRpbWVvdXRNczogMzAwMDAsXG59O1xuY29uc3QgV0VCU09DS0VUX1BST1RPQ09MX0JJTkFSWSA9ICdjb20uc29sYW5hLm1vYmlsZXdhbGxldGFkYXB0ZXIudjEnO1xuY29uc3QgV0VCU09DS0VUX1BST1RPQ09MX0JBU0U2NCA9ICdjb20uc29sYW5hLm1vYmlsZXdhbGxldGFkYXB0ZXIudjEuYmFzZTY0JztcbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUNvbnRleHQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVELCAnVGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBwcm90b2NvbCBtdXN0IGJlIHVzZWQgaW4gYSBzZWN1cmUgY29udGV4dCAoYGh0dHBzYCkuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRVcmlCYXNlKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHdhbGxldFVyaUJhc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdJbnZhbGlkIGJhc2UgVVJMIHN1cHBsaWVkIGJ5IHdhbGxldCcpO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCwgJ0Jhc2UgVVJMcyBzdXBwbGllZCBieSB3YWxsZXRzIG11c3QgYmUgdmFsaWQgYGh0dHBzYCBVUkxzJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoMCwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVZhckxvbmcoYnl0ZUFycmF5KSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSwgbCA9IGJ5dGVBcnJheS5ieXRlTGVuZ3RoLCBsaW1pdCA9IDEwLCB2YWx1ZSA9IDAsIG9mZnNldCA9IDAsIGI7XG4gICAgZG8ge1xuICAgICAgICBpZiAob2Zmc2V0ID49IGwgfHwgb2Zmc2V0ID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRmFpbGVkIHRvIGRlY29kZSB2YXJpbnQnKTtcbiAgICAgICAgYiA9IGJ5dGVzW29mZnNldCsrXTtcbiAgICAgICAgdmFsdWUgfD0gKGIgJiAweDdGKSA8PCAoNyAqIG9mZnNldCk7XG4gICAgfSB3aGlsZSAoYiA+PSAweDgwKTtcbiAgICByZXR1cm4geyB2YWx1ZSwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRSZWZsZWN0b3JJZEZyb21CeXRlQXJyYXkoYnl0ZUFycmF5KSB7XG4gICAgbGV0IHsgdmFsdWU6IGxlbmd0aCwgb2Zmc2V0IH0gPSBkZWNvZGVWYXJMb25nKGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuZnVuY3Rpb24gdHJhbnNhY3QoY2FsbGJhY2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydFNlY3VyZUNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25LZXlwYWlyID0geWllbGQgZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBvcnQgPSB5aWVsZCBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmkpO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRVUkwgPSBgd3M6Ly9sb2NhbGhvc3Q6JHtzZXNzaW9uUG9ydH0vc29sYW5hLXdhbGxldGA7XG4gICAgICAgIGxldCBjb25uZWN0aW9uU3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBnZXROZXh0UmV0cnlEZWxheU1zID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlID0gWy4uLldFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRy5yZXRyeURlbGF5U2NoZWR1bGVNc107XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gKHNjaGVkdWxlLmxlbmd0aCA+IDEgPyBzY2hlZHVsZS5zaGlmdCgpIDogc2NoZWR1bGVbMF0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICBsZXQgbmV4dEpzb25ScGNNZXNzYWdlSWQgPSAxO1xuICAgICAgICBsZXQgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IGpzb25ScGNSZXNwb25zZVByb21pc2VzID0ge307XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGFkYXB0ZXIgc3RhdGUgdG8gYmUgYGNvbm5lY3RpbmdgIGF0IHRoZSBtb21lbnQgdGhlIHdlYnNvY2tldCBvcGVucy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR290IFxcYCR7c3RhdGUuX190eXBlfVxcYC5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGlicmFyeSBhbmQgd2FsbGV0bGliIGluY29ycmVjdGx5IGltcGxlbWVudGVkIHRoZSBNV0Egc2Vzc2lvbiBcbiAgICAgICAgICAgICAgICAvLyBlc3RhYmxpc2htZW50IHByb3RvY29sIGZvciBsb2NhbCBjb25uZWN0aW9ucy4gVGhlIGRhcHAgaXMgc3VwcG9zZWQgdG8gd2FpdCBmb3IgdGhlIFxuICAgICAgICAgICAgICAgIC8vIEFQUF9QSU5HIG1lc3NhZ2UgYmVmb3JlIHNlbmRpbmcgdGhlIEhFTExPX1JFUS4gSW5zdGVhZCwgdGhlIGRhcHAgd2FzIHNlbmRpbmcgdGhlIEhFTExPX1JFUSBcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSB1cG9uIGNvbm5lY3Rpb24gdG8gdGhlIHdlYnNvY2tldCBzZXJ2ZXIgcmVnYXJkbGVzcyBvZiB3ZXRoZXIgb3Igbm90IGFuIFxuICAgICAgICAgICAgICAgIC8vIEFQUF9QSU5HIHdhcyBzZW50IGJ5IHRoZSB3YWxsZXQvd2Vic29ja2V0IHNlcnZlci4gV2UgbXVzdCBjb250aW51ZSB0byBzdXBwb3J0IHRoaXMgYmVoYXZpb3IgXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBpcyB1c2luZyBhIHdhbGxldCB0aGF0IGhhcyBub3QgdXBkYXRlZCB0aGVpciB3YWxsZXRsaWIgaW1wbGVtZW50YXRpb24uIFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXNzb2NpYXRpb25LZXlwYWlyIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgIGVjZGhQcml2YXRlS2V5OiBlY2RoS2V5cGFpci5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldnQud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9DTE9TRUQsIGBUaGUgd2FsbGV0IHNlc3Npb24gZHJvcHBlZCB1bmV4cGVjdGVkbHkgKCR7ZXZ0LmNvZGV9OiAke2V2dC5yZWFzb259KS5gLCB7IGNsb3NlRXZlbnQ6IGV2dCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChfZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gY29ubmVjdGlvblN0YXJ0VGltZSA+PSBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcudGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfU0VTU0lPTl9USU1FT1VULCBgRmFpbGVkIHRvIGNvbm5lY3QgdG8gdGhlIHdhbGxldCB3ZWJzb2NrZXQgYXQgJHt3ZWJzb2NrZXRVUkx9LmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5TXMgPSBnZXROZXh0UmV0cnlEZWxheU1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeVdhaXRUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBldnQuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuX190eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvblB1YmxpY0tleTogYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSByZXNwb25zZUJ1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uUnBjTWVzc2FnZSA9IHlpZWxkIGRlY3J5cHRKc29uUnBjTWVzc2FnZShyZXNwb25zZUJ1ZmZlciwgc3RhdGUuc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2pzb25ScGNNZXNzYWdlLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShqc29uUnBjTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSByZWNlaXZlIGFuIEFQUF9QSU5HIG1lc3NhZ2UgKGVtcHR5IG1lc3NhZ2UpLCByZXNlbmQgdGhlIEhFTExPX1JFUSAoc2VlIGFib3ZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlY2RoS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlRUNESEtleXBhaXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ2hlbGxvX3JlcV9zZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjZGhQcml2YXRlS2V5OiBlY2RoS2V5cGFpci5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB5aWVsZCBwYXJzZUhlbGxvUnNwKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5hc3NvY2lhdGlvblB1YmxpY0tleSwgc3RhdGUuZWNkaFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIgPSByZXNwb25zZUJ1ZmZlci5zbGljZShFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geWllbGQgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBzZXNzaW9uUHJvcGVydGllc0J1ZmZlci5zbGljZSgwLCBTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciAhPT0gKGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGhhcyBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTZXNzaW9uUHJvcHMoc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGVkJywgc2hhcmVkU2VjcmV0LCBzZXNzaW9uUHJvcGVydGllcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkoc2Vzc2lvblByb3BlcnRpZXMucHJvdG9jb2xfdmVyc2lvbiwgKG1ldGhvZCwgcGFyYW1zKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGVuY3J5cHRKc29uUnBjTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ScGNSZXNwb25zZVByb21pc2VzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0aG9yaXplJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldF91cmlfYmFzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHlpZWxkIGNhbGxiYWNrKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2VTb2NrZXQ7XG4gICAgICAgICAgICBsZXQgcmV0cnlXYWl0VGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2VTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnY29ubmVjdGluZycsIGFzc29jaWF0aW9uS2V5cGFpciB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQod2Vic29ja2V0VVJMLCBbV0VCU09DS0VUX1BST1RPQ09MX0JJTkFSWV0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0UmVtb3RlKGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gc3RhcnRSZW1vdGVTY2VuYXJpbyhjb25maWcpLnRoZW4oKHNjZW5hcmlvKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uVXJsOiBzY2VuYXJpby5hc3NvY2lhdGlvblVybCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHNjZW5hcmlvLndhbGxldC50aGVuKCh3YWxsZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBQcm94eSh3YWxsZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocCA9PSAndGVybWluYXRlU2Vzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NlbmFyaW8uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFJlbW90ZVNjZW5hcmlvKGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydFNlY3VyZUNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25LZXlwYWlyID0geWllbGQgZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzczovLyR7Y29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHl9L3JlZmxlY3RgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgbGV0IHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICBsZXQgZGVjb2RlQnl0ZXMgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT0gJ2Jhc2U2NCcpIHsgLy8gYmFzZTY0IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHlpZWxkIGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQ4QXJyYXkobWVzc2FnZSkuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV2dC5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWZsZWN0b3IgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIGNvbm5lY3QgdG8gdGhlIHJlZmxlY3RvciBhbmQgd2FpdCBmb3IgdGhlIFJFRkxFQ1RPUl9JRCBtZXNzYWdlIFxuICAgICAgICAvLyBzbyB3ZSBidWlsZCB0aGUgYXNzb2NpYXRpb24gVVJMIGFuZCByZXR1cm4gdGhhdCBiYWNrIHRvIHRoZSBjYWxsZXJcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGFkYXB0ZXIgc3RhdGUgdG8gYmUgYGNvbm5lY3RpbmdgIGF0IHRoZSBtb21lbnQgdGhlIHdlYnNvY2tldCBvcGVucy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR290IFxcYCR7c3RhdGUuX190eXBlfVxcYC5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnByb3RvY29sLmluY2x1ZGVzKFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmbGVjdG9ySWQgPSBnZXRSZWZsZWN0b3JJZEZyb21CeXRlQXJyYXkocmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ3JlZmxlY3Rvcl9pZF9yZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0b3JJZDogcmVmbGVjdG9ySWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBnZXRSZW1vdGVBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5LCByZWZsZWN0b3JJZCwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmkpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlksIFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjRdKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVmbGVjdG9ySWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYWxsZXQgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIHJldHVybiB0aGUgYXNzb2NpYXRpb24gVVJMIChjb250YWluaW5nIHRoZSByZWZsZWN0b3IgSUQpIHRvIHRoZSBjYWxsZXIgKyBcbiAgICAgICAgLy8gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRoZSBNb2JpbGVXYWxsZXQgb2JqZWN0IG9uY2UgdGhlIHdhbGxldCBjb25uZWN0cy5cbiAgICAgICAgbGV0IHNlc3Npb25Fc3RhYmxpc2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFuZGxlQ2xvc2U7XG4gICAgICAgIHJldHVybiB7IGFzc29jaWF0aW9uVXJsLCBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgICAgICAgICB9LCB3YWxsZXQ6IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNSZXNwb25zZVByb21pc2VzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmbGVjdG9yX2lkX3JlY2VpdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBhd2FpdGluZyByZWZsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjZGhLZXlwYWlyID0geWllbGQgZ2VuZXJhdGVFQ0RIS2V5cGFpcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeU1zZyA9IHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChmcm9tVWludDhBcnJheShiaW5hcnlNc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGJpbmFyeU1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0geWllbGQgZGVjcnlwdEpzb25ScGNNZXNzYWdlKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5zaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKGpzb25ScGNNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllc0J1ZmZlciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVNlc3Npb25Qcm9wcyhzZXNzaW9uUHJvcGVydGllc0J1ZmZlciwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBjcmVhdGVNb2JpbGVXYWxsZXRQcm94eShzZXNzaW9uUHJvcGVydGllcy5wcm90b2NvbF92ZXJzaW9uLCAobWV0aG9kLCBwYXJhbXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlNc2cgPSB5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZnJvbVVpbnQ4QXJyYXkoYmluYXJ5TXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChiaW5hcnlNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25Fc3RhYmxpc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX0NMT1NFRCwgYFRoZSB3YWxsZXQgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uLmAsIHsgY2xvc2VFdmVudDogbmV3IENsb3NlRXZlbnQoJ3NvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uJykgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlLCBTb2xhbmFTaWduSW5XaXRoU29sYW5hLCBTb2xhbmFTaWduVHJhbnNhY3Rpb25zLCBzdGFydFJlbW90ZVNjZW5hcmlvLCB0cmFuc2FjdCwgdHJhbnNhY3RSZW1vdGUgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUiLCJFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSIsIkVSUk9SX1JFRkxFQ1RPUl9JRF9PVVRfT0ZfUkFOR0UiLCJFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMIiwiRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQiLCJFUlJPUl9TRVNTSU9OX0NMT1NFRCIsIkVSUk9SX1NFU1NJT05fVElNRU9VVCIsIkVSUk9SX1dBTExFVF9OT1RfRk9VTkQiLCJFUlJPUl9JTlZBTElEX1BST1RPQ09MX1ZFUlNJT04iLCJFUlJPUl9CUk9XU0VSX05PVF9TVVBQT1JURUQiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiYXJncyIsImNvZGUiLCJtZXNzYWdlIiwiZGF0YSIsIm5hbWUiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUiLCJFUlJPUl9BVVRIT1JJWkFUSU9OX0ZBSUxFRCIsIkVSUk9SX0lOVkFMSURfUEFZTE9BRFMiLCJFUlJPUl9OT1RfU0lHTkVEIiwiRVJST1JfTk9UX1NVQk1JVFRFRCIsIkVSUk9SX1RPT19NQU5ZX1BBWUxPQURTIiwiRVJST1JfQVRURVNUX09SSUdJTl9BTkRST0lEIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IiLCJqc29uUnBjTWVzc2FnZUlkIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZW5jb2RlIiwiaW5wdXQiLCJ3aW5kb3ciLCJidG9hIiwiZnJvbVVpbnQ4QXJyYXkiLCJieXRlQXJyYXkiLCJ1cmxzYWZlIiwiYmFzZTY0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY2FsbCIsInJlcGxhY2UiLCJ0b1VpbnQ4QXJyYXkiLCJiYXNlNjRFbmNvZGVkQnl0ZUFycmF5IiwiVWludDhBcnJheSIsImF0b2IiLCJzcGxpdCIsIm1hcCIsImMiLCJjaGFyQ29kZUF0IiwiY3JlYXRlSGVsbG9SZXEiLCJlY2RoUHVibGljS2V5IiwiYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSIsInB1YmxpY0tleUJ1ZmZlciIsImNyeXB0byIsInN1YnRsZSIsImV4cG9ydEtleSIsInNpZ25hdHVyZUJ1ZmZlciIsInNpZ24iLCJoYXNoIiwicmVzcG9uc2UiLCJieXRlTGVuZ3RoIiwic2V0IiwiY3JlYXRlU0lXU01lc3NhZ2UiLCJwYXlsb2FkIiwiY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQiLCJTb2xhbmFTaWduVHJhbnNhY3Rpb25zIiwiU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uIiwiU29sYW5hU2lnbkluV2l0aFNvbGFuYSIsImNyZWF0ZU1vYmlsZVdhbGxldFByb3h5IiwicHJvdG9jb2xWZXJzaW9uIiwicHJvdG9jb2xSZXF1ZXN0SGFuZGxlciIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicCIsImlucHV0UGFyYW1zIiwibWV0aG9kIiwicGFyYW1zIiwiaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdCIsInNpZ25faW5fcGF5bG9hZCIsInNpZ25faW5fcmVzdWx0Iiwic2lnbkluRmFsbGJhY2siLCJoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZSIsImRlZmluZVByb3BlcnR5IiwiZGVsZXRlUHJvcGVydHkiLCJtZXRob2ROYW1lIiwibWV0aG9kUGFyYW1zIiwidG9TdHJpbmciLCJsZXR0ZXIiLCJ0b0xvd2VyQ2FzZSIsImNoYWluIiwiY2x1c3RlciIsImF1dGhfdG9rZW4iLCJpZGVudGl0eSIsImNhcGFiaWxpdGllcyIsImZlYXR1cmVzIiwic3VwcG9ydHNfY2xvbmVfYXV0aG9yaXphdGlvbiIsInB1c2giLCJPYmplY3QiLCJhc3NpZ24iLCJzdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9ucyIsImluY2x1ZGVzIiwic2lnbkluUGF5bG9hZCIsImF1dGhvcml6YXRpb25SZXN1bHQiLCJfYSIsImRvbWFpbiIsImxvY2F0aW9uIiwiaG9zdCIsImFkZHJlc3MiLCJhY2NvdW50cyIsInNpd3NNZXNzYWdlIiwic2lnbk1lc3NhZ2VSZXN1bHQiLCJhZGRyZXNzZXMiLCJwYXlsb2FkcyIsInNpZ25JblJlc3VsdCIsInNpZ25lZF9tZXNzYWdlIiwic2lnbmF0dXJlIiwic2lnbmVkX3BheWxvYWRzIiwic2xpY2UiLCJsZW5ndGgiLCJTRVFVRU5DRV9OVU1CRVJfQllURVMiLCJjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvciIsInNlcXVlbmNlTnVtYmVyIiwiQXJyYXlCdWZmZXIiLCJ2aWV3IiwiRGF0YVZpZXciLCJzZXRVaW50MzIiLCJJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMiLCJFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTIiwiZW5jcnlwdE1lc3NhZ2UiLCJwbGFpbnRleHQiLCJzaGFyZWRTZWNyZXQiLCJzZXF1ZW5jZU51bWJlclZlY3RvciIsImluaXRpYWxpemF0aW9uVmVjdG9yIiwiZ2V0UmFuZG9tVmFsdWVzIiwiY2lwaGVydGV4dCIsImVuY3J5cHQiLCJnZXRBbGdvcml0aG1QYXJhbXMiLCJUZXh0RW5jb2RlciIsImRlY3J5cHRNZXNzYWdlIiwicGxhaW50ZXh0QnVmZmVyIiwiZGVjcnlwdCIsImdldFV0ZjhEZWNvZGVyIiwiZGVjb2RlIiwiYWRkaXRpb25hbERhdGEiLCJpdiIsInRhZ0xlbmd0aCIsIl91dGY4RGVjb2RlciIsInVuZGVmaW5lZCIsIlRleHREZWNvZGVyIiwiZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIiLCJnZW5lcmF0ZUtleSIsIm5hbWVkQ3VydmUiLCJnZW5lcmF0ZUVDREhLZXlwYWlyIiwiYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyIsImJ1ZmZlciIsImJpbmFyeSIsImJ5dGVzIiwibGVuIiwiaWkiLCJnZXRSYW5kb21Bc3NvY2lhdGlvblBvcnQiLCJhc3NlcnRBc3NvY2lhdGlvblBvcnQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwb3J0IiwiZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZCIsInVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmciLCJtIiwiSU5URU5UX05BTUUiLCJnZXRQYXRoUGFydHMiLCJwYXRoU3RyaW5nIiwiZ2V0SW50ZW50VVJMIiwibWV0aG9kUGF0aG5hbWUiLCJpbnRlbnRVcmxCYXNlIiwiYmFzZVVybCIsIlVSTCIsInByb3RvY29sIiwicGF0aG5hbWUiLCJzdGFydHNXaXRoIiwiam9pbiIsImdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwiLCJhc3NvY2lhdGlvblB1YmxpY0tleSIsInB1dGF0aXZlUG9ydCIsImFzc29jaWF0aW9uVVJMQmFzZSIsInByb3RvY29sVmVyc2lvbnMiLCJhc3NvY2lhdGlvblBvcnQiLCJleHBvcnRlZEtleSIsImVuY29kZWRLZXkiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwidmVyc2lvbiIsImdldFJlbW90ZUFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwiLCJob3N0QXV0aG9yaXR5IiwicmVmbGVjdG9ySWQiLCJlbmNyeXB0SnNvblJwY01lc3NhZ2UiLCJqc29uUnBjTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZCIsImRlY3J5cHRKc29uUnBjTWVzc2FnZSIsInBhcnNlIiwiaGFzT3duUHJvcGVydHkiLCJlcnJvciIsInBhcnNlSGVsbG9Sc3AiLCJwYXlsb2FkQnVmZmVyIiwiZWNkaFByaXZhdGVLZXkiLCJhc3NvY2lhdGlvblB1YmxpY0tleUJ1ZmZlciIsIndhbGxldFB1YmxpY0tleSIsImFsbCIsImltcG9ydEtleSIsImRlcml2ZUJpdHMiLCJwdWJsaWMiLCJlY2RoU2VjcmV0S2V5IiwiYWVzS2V5TWF0ZXJpYWxWYWwiLCJkZXJpdmVLZXkiLCJzYWx0IiwiaW5mbyIsInBhcnNlU2Vzc2lvblByb3BzIiwianNvblByb3BlcnRpZXMiLCJ2IiwicHJvdG9jb2xfdmVyc2lvbiIsIkJyb3dzZXIiLCJGaXJlZm94IiwiT3RoZXIiLCJhc3NlcnRVbnJlYWNoYWJsZSIsIngiLCJnZXRCcm93c2VyIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImdldERldGVjdGlvblByb21pc2UiLCJjbGVhbnVwIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dElkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUJsdXIiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsIl9mcmFtZSIsImxhdW5jaFVybFRocm91Z2hIaWRkZW5GcmFtZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnRXaW5kb3ciLCJocmVmIiwibGF1bmNoQXNzb2NpYXRpb24iLCJhc3NvY2lhdGlvblVybCIsImJyb3dzZXIiLCJkZXRlY3Rpb25Qcm9taXNlIiwic3RhcnRTZXNzaW9uIiwicmFuZG9tQXNzb2NpYXRpb25Qb3J0IiwiV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHIiwicmV0cnlEZWxheVNjaGVkdWxlTXMiLCJ0aW1lb3V0TXMiLCJXRUJTT0NLRVRfUFJPVE9DT0xfQklOQVJZIiwiV0VCU09DS0VUX1BST1RPQ09MX0JBU0U2NCIsImFzc2VydFNlY3VyZUNvbnRleHQiLCJpc1NlY3VyZUNvbnRleHQiLCJhc3NlcnRTZWN1cmVFbmRwb2ludFNwZWNpZmljVVJJIiwid2FsbGV0VXJpQmFzZSIsImdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheSIsImdldFVpbnQzMiIsImRlY29kZVZhckxvbmciLCJsIiwibGltaXQiLCJvZmZzZXQiLCJiIiwiUmFuZ2VFcnJvciIsImdldFJlZmxlY3RvcklkRnJvbUJ5dGVBcnJheSIsInRyYW5zYWN0IiwiY2FsbGJhY2siLCJjb25maWciLCJhc3NvY2lhdGlvbktleXBhaXIiLCJzZXNzaW9uUG9ydCIsInB1YmxpY0tleSIsImJhc2VVcmkiLCJ3ZWJzb2NrZXRVUkwiLCJjb25uZWN0aW9uU3RhcnRUaW1lIiwiZ2V0TmV4dFJldHJ5RGVsYXlNcyIsInNjaGVkdWxlIiwic2hpZnQiLCJuZXh0SnNvblJwY01lc3NhZ2VJZCIsImxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciIsInN0YXRlIiwiX190eXBlIiwic29ja2V0IiwianNvblJwY1Jlc3BvbnNlUHJvbWlzZXMiLCJoYW5kbGVPcGVuIiwiY29uc29sZSIsIndhcm4iLCJlY2RoS2V5cGFpciIsInNlbmQiLCJwcml2YXRlS2V5IiwiaGFuZGxlQ2xvc2UiLCJldnQiLCJ3YXNDbGVhbiIsInJlYXNvbiIsImNsb3NlRXZlbnQiLCJkaXNwb3NlU29ja2V0IiwiaGFuZGxlRXJyb3IiLCJfZXZ0IiwiRGF0ZSIsIm5vdyIsInJldHJ5RGVsYXlNcyIsInJldHJ5V2FpdFRpbWVvdXRJZCIsImF0dGVtcHRTb2NrZXRDb25uZWN0aW9uIiwiaGFuZGxlTWVzc2FnZSIsInJlc3BvbnNlQnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJyZXNwb25zZVByb21pc2UiLCJzZXNzaW9uUHJvcGVydGllc0J1ZmZlciIsInNlc3Npb25Qcm9wZXJ0aWVzIiwid2FsbGV0IiwianNvbnJwYyIsIndhbGxldF91cmlfYmFzZSIsImNsb3NlIiwiV2ViU29ja2V0IiwidHJhbnNhY3RSZW1vdGUiLCJzdGFydFJlbW90ZVNjZW5hcmlvIiwic2NlbmFyaW8iLCJyZW1vdGVIb3N0QXV0aG9yaXR5IiwiZW5jb2RpbmciLCJkZWNvZGVCeXRlcyIsImhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSIsInNlc3Npb25Fc3RhYmxpc2hlZCIsImJpbmFyeU1zZyIsIkNsb3NlRXZlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaMobileWalletAdapter: () => (/* binding */ SolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapterRemote: () => (/* binding */ SolanaMobileWalletAdapterRemote),\n/* harmony export */   SolanaMobileWalletAdapterRemoteWalletName: () => (/* binding */ SolanaMobileWalletAdapterRemoteWalletName),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAddressSelector: () => (/* binding */ createDefaultAddressSelector),\n/* harmony export */   createDefaultAuthorizationResultCache: () => (/* binding */ createDefaultAuthorizationResultCache),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol-web3js */ \"(ssr)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/qrcode/lib/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window.atob(base64EncodedByteArray).split(\"\").map((c)=>c.charCodeAt(0)));\n}\nfunction getIsSupported$1() {\n    return  false && 0;\n}\nconst SolanaMobileWalletAdapterWalletName = \"Mobile Wallet Adapter\";\nconst SIGNATURE_LENGTH_IN_BYTES$1 = 64;\nfunction getPublicKeyFromAddress$1(address) {\n    const publicKeyByteArray = toUint8Array(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n}\nfunction clusterToChainId(cluster) {\n    switch(cluster){\n        case \"mainnet-beta\":\n            return \"solana:mainnet\";\n        case \"testnet\":\n            return \"solana:testnet\";\n        case \"devnet\":\n            return \"solana:devnet\";\n    }\n}\nclass SolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config){\n        var _a;\n        super();\n        this.supportedTransactionVersions = new Set(// FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        [\n            \"legacy\",\n            0\n        ]);\n        this.name = SolanaMobileWalletAdapterWalletName;\n        this.url = \"https://solanamobile.com/wallets\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==\";\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */ this._connectionGeneration = 0;\n        this._readyState = getIsSupported$1() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : clusterToChainId(config.cluster);\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult)=>{\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress);\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit(\"readyStateChange\", this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed);\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield callback();\n            } catch (e) {\n                this.emit(\"error\", e);\n                throw e;\n            }\n        });\n    }\n    /** @deprecated Use `autoConnect()` instead. */ autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                        if (cachedAuthorizationResult) {\n                            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                            this.handleAuthorizationResult(cachedAuthorizationResult);\n                        }\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        yield this.performAuthorization();\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        const authorizationResult = yield wallet.authorize({\n                            chain: this._chain,\n                            identity: this._appIdentity,\n                            sign_in_payload: signInPayload\n                        });\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        Promise.all([\n                            this._authorizationResultCache.set(authorizationResult),\n                            this.handleAuthorizationResult(authorizationResult)\n                        ]);\n                        return authorizationResult;\n                    }));\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const didPublicKeysChange = // Case 1: We started from having no authorization.\n            this._authorizationResult == null || // Case 2: The number of authorized accounts changed.\n            ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n            this._authorizationResult.accounts.some((account, ii)=>account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address })=>address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit(\"connect\", // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult)\n                ]);\n            } catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            this.emit(\"disconnect\");\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const config = walletUriBase ? {\n                baseUri: walletUriBase\n            } : undefined;\n            const remoteConfig = this._hostAuthority ? {\n                remoteHostAuthority: this._hostAuthority\n            } : undefined;\n            const currentConnectionGeneration = this._connectionGeneration;\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, Object.assign(Object.assign({}, config), remoteConfig));\n            } catch (e) {\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(()=>{}); // Never resolve.\n                }\n                if (e instanceof Error && e.name === \"SolanaMobileWalletAdapterError\" && e.code === \"ERROR_WALLET_NOT_FOUND\") {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.performReauthorization(wallet, authToken);\n                        const signedTransactions = yield wallet.signTransactions({\n                            transactions\n                        });\n                        return signedTransactions;\n                    }));\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken } = this.assertIsAuthorized();\n                    const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                function getTargetCommitment() {\n                                    let targetCommitment;\n                                    switch(connection.commitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetCommitment = connection.commitment;\n                                            break;\n                                        default:\n                                            targetCommitment = \"finalized\";\n                                    }\n                                    let targetPreflightCommitment;\n                                    switch(options === null || options === void 0 ? void 0 : options.preflightCommitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetPreflightCommitment = options.preflightCommitment;\n                                            break;\n                                        case undefined:\n                                            targetPreflightCommitment = targetCommitment;\n                                            break;\n                                        default:\n                                            targetPreflightCommitment = \"finalized\";\n                                    }\n                                    const preflightCommitmentScore = targetPreflightCommitment === \"finalized\" ? 2 : targetPreflightCommitment === \"confirmed\" ? 1 : 0;\n                                    const targetCommitmentScore = targetCommitment === \"finalized\" ? 2 : targetCommitment === \"confirmed\" ? 1 : 0;\n                                    return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n                                }\n                                const [capabilities, _1, _2] = yield Promise.all([\n                                    wallet.getCapabilities(),\n                                    this.performReauthorization(wallet, authToken),\n                                    isVersionedTransaction(transaction) ? null : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */ (()=>__awaiter(this, void 0, void 0, function*() {\n                                            var _a;\n                                            transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                            if (transaction.recentBlockhash == null) {\n                                                const { blockhash } = yield connection.getLatestBlockhash({\n                                                    commitment: getTargetCommitment()\n                                                });\n                                                transaction.recentBlockhash = blockhash;\n                                            }\n                                        }))()\n                                ]);\n                                if (capabilities.supports_sign_and_send_transactions) {\n                                    const signatures = yield wallet.signAndSendTransactions({\n                                        minContextSlot,\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    return signatures[0];\n                                } else {\n                                    const [signedTransaction] = yield wallet.signTransactions({\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    if (isVersionedTransaction(signedTransaction)) {\n                                        return yield connection.sendTransaction(signedTransaction);\n                                    } else {\n                                        const serializedTransaction = signedTransaction.serialize();\n                                        return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                                            preflightCommitment: getTargetCommitment()\n                                        }));\n                                    }\n                                }\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const [signedTransaction] = yield this.performSignTransactions([\n                        transaction\n                    ]);\n                    return signedTransaction;\n                }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const signedTransactions = yield this.performSignTransactions(transactions);\n                    return signedTransactions;\n                }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken, selectedAddress } = this.assertIsAuthorized();\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                yield this.performReauthorization(wallet, authToken);\n                                const [signedMessage] = yield wallet.signMessages({\n                                    addresses: [\n                                        selectedAddress\n                                    ],\n                                    payloads: [\n                                        message\n                                    ]\n                                });\n                                const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES$1);\n                                return signature;\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n                            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n                        }));\n                        if (!authorizationResult.sign_in_result) {\n                            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                        }\n                        const signedInAddress = authorizationResult.sign_in_result.address;\n                        const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find((acc)=>acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                            address: signedInAddress\n                        }), {\n                            publicKey: toUint8Array(signedInAddress)\n                        });\n                        return {\n                            account: signedInAccount,\n                            signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                            signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                        };\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n}\nconst BluetoothHtml = `\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n    <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n        <svg width=\"14\" height=\"14\">\r\n        <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n        </svg>\r\n    </button>\r\n    <h1><b>Jupiter</b> wants to connect</h1>\r\n    <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Connect to your mobile wallet app through Bluetooth.</p>\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-connection-status-container\">\r\n        <div id=\"status-not-connected\" class=\"connection-status\">\r\n        <svg class=\"bluetooth-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#a0a0a0\" d=\"M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z\"/>\r\n        </svg>\r\n        <p>Not connected</p>\r\n        </div>\r\n        <div id=\"status-connecting\" class=\"connection-status\" style=\"display:none;\">\r\n        <div class=\"spinner\"></div>\r\n        <p>Connecting...</p>\r\n        </div>\r\n        <div id=\"status-connected\" class=\"connection-status\" style=\"display:none;\">\r\n        <svg class=\"checkmark-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#4CAF50\" d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\"/>\r\n        </svg>\r\n        <p>Connected</p>\r\n        </div>\r\n    </div>\r\n    <div class=\"button-group\">\r\n        <button id=\"cancel-btn\" class=\"cancel-btn\">Cancel</button>\r\n        <button id=\"connect-btn\" class=\"connect-btn\">Connect</button>\r\n    </div>\r\n    </div>\r\n`;\nconst QRCodeHtml = `\r\n<div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n  <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n    <svg width=\"14\" height=\"14\">\r\n      <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n    </svg>\r\n  </button>\r\n  <h1>Scan to connect</h1>\r\n  <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Use your wallet app to scan the QR Code and connect.</p>\r\n  <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" />\r\n</div>\r\n`;\nconst css = `\r\n.mobile-wallet-adapter-embedded-modal {\r\n    display: flex; /* Use flexbox to center content */\r\n    flex-direction: column;\r\n    justify-content: center; /* Center horizontally */\r\n    align-items: center; /* Center vertically */\r\n    position: fixed; /* Stay in place */\r\n    z-index: 1; /* Sit on top */\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%; /* Full width */\r\n    height: 100%; /* Full height */\r\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-content {\r\n    background: #10141f;\r\n    padding: 20px;\r\n    border-radius: 10px;\r\n    width: 80%;\r\n    max-width: 500px;\r\n    text-align: center;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center; /* Center children horizontally */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-subtitle {\r\n    color: #D8D8D8;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    position: absolute;\r\n    top: 18px;\r\n    right: 18px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    background: #1a1f2e;\r\n    border: none;\r\n    border-radius: 50%;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\r\n    outline-color: white;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close svg {\r\n    fill: #777;\r\n    transition: fill 200ms ease 0s;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\r\n    fill: #fff;\r\n}\r\n\r\n.icon-container {\r\n    display: flex;\r\n    justify-content: center;\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.icon {\r\n    width: 80px;\r\n    height: 80px;\r\n    border-radius: 50%;\r\n    background-color: #ddd; /* Placeholder for icon background */\r\n}\r\n\r\n/* Modal Title */\r\n.mobile-wallet-adapter-embedded-modal-content h1 {\r\n    color: white;\r\n    font-size: 24px;   \r\n}\r\n\r\n.button-group {\r\n    display: flex;\r\n    width: 100%;\r\n    gap: 10px;\r\n}\r\n\r\n.connect-btn, .cancel-btn {\r\n    flex: 1;\r\n    padding: 12px 20px;\r\n    font-size: 16px;\r\n    cursor: pointer;\r\n    border-radius: 10px;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.connect-btn {\r\n    background-color: #007bff;\r\n    color: white;\r\n    border: none;\r\n}\r\n\r\n.connect-btn:hover {\r\n    background-color: #0056b3;\r\n}\r\n\r\n.cancel-btn {\r\n    background-color: transparent;\r\n    color: #a0a0a0;\r\n    border: 1px solid #a0a0a0;\r\n}\r\n\r\n.cancel-btn:hover {\r\n    background-color: rgba(160, 160, 160, 0.1);\r\n}\r\n\r\n/* BT Connection Status */\r\n\r\n.mobile-wallet-adapter-embedded-modal-connection-status-container {\r\n    margin: 20px 0px 20px 0px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    margin: 20px 0;\r\n}\r\n  \r\n.connection-status p {\r\n    margin-top: 10px;\r\n    color: #a0a0a0;\r\n}\r\n  \r\n.bluetooth-icon, .checkmark-icon {\r\n    width: 48px;\r\n    height: 48px;\r\n}\r\n  \r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid #3498db;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n}\r\n  \r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n/* QR Code */\r\n\r\n#mobile-wallet-adapter-embedded-modal-qr-code-container {\r\n    width: 500px;\r\n    height: 500px;\r\n    align-content: center;\r\n}\r\n`;\nclass EmbeddedModal {\n    constructor(title){\n        this._root = null;\n        this._title = title;\n        // Bind methods to ensure `this` context is correct\n        this.init = this.init.bind(this);\n        this.injectQRCodeHTML = this.injectQRCodeHTML.bind(this);\n        this.injectBluetoothHTML = this.injectBluetoothHTML.bind(this);\n        this.open = this.open.bind(this);\n        this.close = this.close.bind(this);\n        this.connect = this.connect.bind(this);\n        this._root = document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\");\n    }\n    init(qrCode) {\n        return __awaiter(this, void 0, void 0, function*() {\n            console.log(\"Injecting modal\");\n            this.injectStyles();\n            this.injectQRCodeHTML(qrCode);\n        });\n    }\n    setConnectionStatus(status) {\n        if (!this._root) return;\n        const statuses = [\n            \"not-connected\",\n            \"connecting\",\n            \"connected\"\n        ];\n        statuses.forEach((s)=>{\n            const el = this._root.querySelector(`#status-${s}`);\n            if (el instanceof HTMLElement) {\n                el.style.display = s === status ? \"flex\" : \"none\";\n            }\n        });\n    }\n    injectStyles() {\n        // Check if the styles have already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-styles\")) {\n            return;\n        }\n        const styleElement = document.createElement(\"style\");\n        styleElement.id = \"mobile-wallet-adapter-styles\";\n        styleElement.textContent = css;\n        document.head.appendChild(styleElement);\n    }\n    populateQRCode(qrUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const qrcodeContainer = document.getElementById(\"mobile-wallet-adapter-embedded-modal-qr-code-container\");\n            if (qrcodeContainer) {\n                const qrCodeElement = yield qrcode__WEBPACK_IMPORTED_MODULE_2__.toCanvas(qrUrl, {\n                    width: 400\n                });\n                if (qrcodeContainer.firstElementChild !== null) {\n                    qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n                } else qrcodeContainer.appendChild(qrCodeElement);\n            } else {\n                console.error(\"QRCode Container not found\");\n            }\n        });\n    }\n    injectQRCodeHTML(qrCode) {\n        // Check if the HTML has already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\")) {\n            if (!this._root) this._root = document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\");\n            this.populateQRCode(qrCode);\n            return;\n        }\n        // Create a container for the modal\n        this._root = document.createElement(\"div\");\n        this._root.id = \"mobile-wallet-adapter-embedded-root-ui\";\n        this._root.className = \"mobile-wallet-adapter-embedded-modal\";\n        this._root.innerHTML = QRCodeHtml;\n        this._root.style.display = \"none\";\n        // Append the modal to the body\n        document.body.appendChild(this._root);\n        // Render the QRCode\n        this.populateQRCode(qrCode);\n        this.attachEventListeners();\n    }\n    injectBluetoothHTML() {\n        // Check if the HTML has already been injected\n        if (document.getElementById(\"mobile-wallet-adapter-embedded-root-ui\")) {\n            return;\n        }\n        this._root = document.createElement(\"div\");\n        this._root.id = \"mobile-wallet-adapter-embedded-root-ui\";\n        this._root.className = \"mobile-wallet-adapter-embedded-modal\";\n        this._root.innerHTML = BluetoothHtml;\n        document.body.appendChild(this._root);\n        this.attachEventListeners();\n    }\n    attachEventListeners() {\n        if (!this._root) return;\n        const closeBtn = this._root.querySelector(\"#mobile-wallet-adapter-embedded-modal-close\");\n        const cancelBtn = this._root.querySelector(\"#cancel-btn\");\n        const connectBtn = this._root.querySelector(\"#connect-btn\");\n        closeBtn === null || closeBtn === void 0 ? void 0 : closeBtn.addEventListener(\"click\", ()=>this.close());\n        cancelBtn === null || cancelBtn === void 0 ? void 0 : cancelBtn.addEventListener(\"click\", ()=>this.close());\n        connectBtn === null || connectBtn === void 0 ? void 0 : connectBtn.addEventListener(\"click\", ()=>this.connect());\n    }\n    open() {\n        console.debug(\"Modal open\");\n        if (this._root) {\n            this._root.style.display = \"flex\";\n            this.setConnectionStatus(\"not-connected\"); // Reset status when opening\n        }\n    }\n    close() {\n        console.debug(\"Modal close\");\n        if (this._root) {\n            this._root.style.display = \"none\";\n            this.setConnectionStatus(\"not-connected\"); // Reset status when closing\n        }\n    }\n    connect() {\n        console.log(\"Connecting...\");\n        // Mock connection\n        this.setConnectionStatus(\"connecting\");\n        // Simulate connection process\n        setTimeout(()=>{\n            this.setConnectionStatus(\"connected\");\n            console.log(\"Connected!\");\n        }, 5000); // 5 seconds delay\n    }\n}\nconst SolanaMobileWalletAdapterRemoteWalletName = \"MWA (Remote)\";\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n    const publicKeyByteArray = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\n/**\n * Determine the mobile operating system.\n * Returns true if running on a mobile operating system, or false otherwise.\n *\n * @returns {boolean}\n */ function isMobileOperatingSystem() {\n    var userAgent = navigator.userAgent;\n    // Windows Phone must come first because its UA also contains \"Android\"\n    if (/windows phone/i.test(userAgent)) {\n        return true;\n    }\n    if (/android/i.test(userAgent)) {\n        return true;\n    }\n    // iOS detection from: http://stackoverflow.com/a/9039885/177710\n    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {\n        return true;\n    }\n    return false;\n}\nfunction getIsSupported() {\n    return  false && 0;\n}\n/**\n * This burner wallet adapter is unsafe to use and is only included to provide an easy way for applications to test\n * Wallet Adapter without using a third-party wallet.\n */ class SolanaMobileWalletAdapterRemote extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config){\n        super();\n        this.supportedTransactionVersions = new Set(// FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        [\n            \"legacy\",\n            0\n        ]);\n        this.name = SolanaMobileWalletAdapterRemoteWalletName;\n        this.url = \"https://solanamobile.com/wallets\";\n        this.icon = \"data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==\";\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */ this._connectionGeneration = 0;\n        this._readyState = getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = config.chain;\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult)=>{\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit(\"readyStateChange\", this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed);\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield callback();\n            } catch (e) {\n                this.emit(\"error\", e);\n                throw e;\n            }\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                        if (cachedAuthorizationResult) {\n                            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                            this.handleAuthorizationResult(cachedAuthorizationResult);\n                        }\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        yield this.performAuthorization();\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                if (this._wallet) delete this._wallet;\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        this._wallet = wallet;\n                        const authorizationResult = yield wallet.authorize({\n                            chain: this._chain,\n                            identity: this._appIdentity,\n                            sign_in_payload: signInPayload\n                        });\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        Promise.all([\n                            this._authorizationResultCache.set(authorizationResult),\n                            this.handleAuthorizationResult(authorizationResult)\n                        ]);\n                        return authorizationResult;\n                    }));\n            } catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const didPublicKeysChange = // Case 1: We started from having no authorization.\n            this._authorizationResult == null || // Case 2: The number of authorized accounts changed.\n            ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length || // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n            this._authorizationResult.accounts.some((account, ii)=>account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address })=>address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit(\"connect\", // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult)\n                ]);\n            } catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\", e);\n            }\n        });\n    }\n    disconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO: figure out why this call throws \"TypeError: _a.terminateSession is not a function\"\n            //  even though the session termination is actually executed (websocket closes). \n            try {\n                (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.terminateSession();\n            } catch (e) {}\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            delete this._wallet;\n            this.emit(\"disconnect\");\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const baseConfig = walletUriBase ? {\n                baseUri: walletUriBase\n            } : undefined;\n            const remoteConfig = Object.assign(Object.assign({}, baseConfig), {\n                remoteHostAuthority: this._hostAuthority\n            });\n            const currentConnectionGeneration = this._connectionGeneration;\n            const modal = new EmbeddedModal(\"MWA QR\");\n            if (this._wallet) {\n                return callback(this._wallet);\n            }\n            try {\n                const { associationUrl, result: promise } = yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transactRemote)((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        const result = yield callback(wallet);\n                        modal.close();\n                        return result;\n                    }), remoteConfig);\n                modal.init(associationUrl.toString());\n                modal.open();\n                return yield promise;\n            } catch (e) {\n                modal.close();\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(()=>{}); // Never resolve.\n                }\n                if (e instanceof Error && e.name === \"SolanaMobileWalletAdapterError\" && e.code === \"ERROR_WALLET_NOT_FOUND\") {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.performReauthorization(wallet, authToken);\n                        const signedTransactions = yield wallet.signTransactions({\n                            transactions\n                        });\n                        return signedTransactions;\n                    }));\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken } = this.assertIsAuthorized();\n                    const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                function getTargetCommitment() {\n                                    let targetCommitment;\n                                    switch(connection.commitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetCommitment = connection.commitment;\n                                            break;\n                                        default:\n                                            targetCommitment = \"finalized\";\n                                    }\n                                    let targetPreflightCommitment;\n                                    switch(options === null || options === void 0 ? void 0 : options.preflightCommitment){\n                                        case \"confirmed\":\n                                        case \"finalized\":\n                                        case \"processed\":\n                                            targetPreflightCommitment = options.preflightCommitment;\n                                            break;\n                                        case undefined:\n                                            targetPreflightCommitment = targetCommitment;\n                                            break;\n                                        default:\n                                            targetPreflightCommitment = \"finalized\";\n                                    }\n                                    const preflightCommitmentScore = targetPreflightCommitment === \"finalized\" ? 2 : targetPreflightCommitment === \"confirmed\" ? 1 : 0;\n                                    const targetCommitmentScore = targetCommitment === \"finalized\" ? 2 : targetCommitment === \"confirmed\" ? 1 : 0;\n                                    return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n                                }\n                                const [capabilities, _1, _2] = yield Promise.all([\n                                    wallet.getCapabilities(),\n                                    this.performReauthorization(wallet, authToken),\n                                    (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(transaction) ? null : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */ (()=>__awaiter(this, void 0, void 0, function*() {\n                                            var _a;\n                                            transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                            if (transaction.recentBlockhash == null) {\n                                                const { blockhash } = yield connection.getLatestBlockhash({\n                                                    commitment: getTargetCommitment()\n                                                });\n                                                transaction.recentBlockhash = blockhash;\n                                            }\n                                        }))()\n                                ]);\n                                if (capabilities.supports_sign_and_send_transactions) {\n                                    const signatures = yield wallet.signAndSendTransactions({\n                                        minContextSlot,\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    return signatures[0];\n                                } else {\n                                    const [signedTransaction] = yield wallet.signTransactions({\n                                        transactions: [\n                                            transaction\n                                        ]\n                                    });\n                                    if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(signedTransaction)) {\n                                        return yield connection.sendTransaction(signedTransaction);\n                                    } else {\n                                        const serializedTransaction = signedTransaction.serialize();\n                                        return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                                            preflightCommitment: getTargetCommitment()\n                                        }));\n                                    }\n                                }\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const [signedTransaction] = yield this.performSignTransactions([\n                        transaction\n                    ]);\n                    return signedTransaction;\n                }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const signedTransactions = yield this.performSignTransactions(transactions);\n                    return signedTransactions;\n                }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    const { authToken, selectedAddress } = this.assertIsAuthorized();\n                    try {\n                        return yield this.transact((wallet)=>__awaiter(this, void 0, void 0, function*() {\n                                yield this.performReauthorization(wallet, authToken);\n                                const [signedMessage] = yield wallet.signMessages({\n                                    addresses: [\n                                        selectedAddress\n                                    ],\n                                    payloads: [\n                                        message\n                                    ]\n                                });\n                                const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n                                return signature;\n                            }));\n                    } catch (error) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.runWithGuard(()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b;\n                    if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                    }\n                    this._connecting = true;\n                    try {\n                        const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n                            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n                        }));\n                        if (!authorizationResult.sign_in_result) {\n                            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                        }\n                        const signedInAddress = authorizationResult.sign_in_result.address;\n                        const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find((acc)=>acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                            address: signedInAddress\n                        }), {\n                            publicKey: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(signedInAddress)\n                        });\n                        return {\n                            account: signedInAccount,\n                            signedMessage: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signed_message),\n                            signature: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signature)\n                        };\n                    } catch (e) {\n                        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError(e instanceof Error && e.message || \"Unknown error\", e);\n                    } finally{\n                        this._connecting = false;\n                    }\n                }));\n        });\n    }\n}\nfunction createDefaultAddressSelector() {\n    return {\n        select (addresses) {\n            return __awaiter(this, void 0, void 0, function*() {\n                return addresses[0];\n            });\n        }\n    };\n}\nconst CACHE_KEY = \"SolanaMobileWalletAdapterDefaultAuthorizationCache\";\nfunction createDefaultAuthorizationResultCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n    // eslint-disable-next-line no-empty\n    } catch (_a) {}\n    return {\n        clear () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        get () {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        },\n        set (authorizationResult) {\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n                // eslint-disable-next-line no-empty\n                } catch (_a) {}\n            });\n        }\n    };\n}\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (false) {}\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZWO0FBQ2pUO0FBQ29EO0FBQ3BFO0FBQytCO0FBRTNEOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTa0IsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU2QsYUFBYXFCLHNCQUFzQjtJQUN4QyxPQUFPLElBQUlDLFdBQVdDLE9BQ2pCQyxJQUFJLENBQUNILHdCQUNMSSxL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Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQUEsUUFBUUUsVUFBVSxDQUFDSjtnQkFDbkIsb0NBQW9DO2dCQUN4QyxFQUNBLE9BQU9uTSxJQUFJLENBQUU7WUFDakI7UUFDSjtRQUNBdUI7WUFDSSxPQUFPbkUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztnQkFDbkMsSUFBSSxDQUFDaVAsU0FBUztvQkFDVjtnQkFDSjtnQkFDQSxJQUFJO29CQUNBLE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0osUUFBUUssT0FBTyxDQUFDUCxlQUFlL0g7Z0JBQ2pELG9DQUFvQztnQkFDeEMsRUFDQSxPQUFPcEUsSUFBSSxDQUFFO1lBQ2pCO1FBQ0o7UUFDQW1ELEtBQUkzQixtQkFBbUI7WUFDbkIsT0FBT3BFLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ25DLElBQUksQ0FBQ2lQLFNBQVM7b0JBQ1Y7Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQUEsUUFBUU0sT0FBTyxDQUFDUixXQUFXSyxLQUFLSSxTQUFTLENBQUNwTDtnQkFDMUMsb0NBQW9DO2dCQUN4QyxFQUNBLE9BQU94QixJQUFJLENBQUU7WUFDakI7UUFDSjtJQUNKO0FBQ0o7QUFFQSxTQUFTNk0sNkJBQTZCQyxtQkFBbUI7SUFDckQsT0FBTzFQLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0w7QUFDSjtBQUNBLFNBQVMyUDtJQUNMLE9BQU9GO0FBQ1g7QUFFK1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tY3AtY29pbi8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbGliL2VzbS9pbmRleC5qcz8zZjE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciwgV2FsbGV0UmVhZHlTdGF0ZSwgV2FsbGV0UHVibGljS2V5RXJyb3IsIFdhbGxldE5vdFJlYWR5RXJyb3IsIFdhbGxldENvbm5lY3Rpb25FcnJvciwgV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdENvbm5lY3RlZEVycm9yLCBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciwgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNpZ25NZXNzYWdlRXJyb3IsIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24gYXMgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiQxIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCwgdHJhbnNhY3RSZW1vdGUgfSBmcm9tICdAc29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wtd2ViM2pzJztcbmltcG9ydCBRUkNvZGUgZnJvbSAncXJjb2RlJztcbmltcG9ydCB7IHRvVWludDhBcnJheSBhcyB0b1VpbnQ4QXJyYXkkMSB9IGZyb20gJ2pzLWJhc2U2NCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3aW5kb3dcbiAgICAgICAgLmF0b2IoYmFzZTY0RW5jb2RlZEJ5dGVBcnJheSlcbiAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXNTdXBwb3J0ZWQkMSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xufVxuXG5jb25zdCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSA9ICdNb2JpbGUgV2FsbGV0IEFkYXB0ZXInO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyQxID0gNjQ7XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyQxKGFkZHJlc3MpIHtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlQXJyYXkgPSB0b1VpbnQ4QXJyYXkoYWRkcmVzcyk7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZUFycmF5KTtcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uO1xufVxuZnVuY3Rpb24gY2x1c3RlclRvQ2hhaW5JZChjbHVzdGVyKSB7XG4gICAgc3dpdGNoIChjbHVzdGVyKSB7XG4gICAgICAgIGNhc2UgJ21haW5uZXQtYmV0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ3NvbGFuYTptYWlubmV0JztcbiAgICAgICAgY2FzZSAndGVzdG5ldCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NvbGFuYTp0ZXN0bmV0JztcbiAgICAgICAgY2FzZSAnZGV2bmV0JzpcbiAgICAgICAgICAgIHJldHVybiAnc29sYW5hOmRldm5ldCc7XG4gICAgfVxufVxuY2xhc3MgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zID0gbmV3IFNldChcbiAgICAgICAgLy8gRklYTUUoIzI0NCk6IFdlIGNhbid0IGFjdHVhbGx5IGtub3cgd2hhdCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkIHVudGlsIHdlIGtub3cgd2hpY2ggd2FsbGV0IHdlJ3JlIHRhbGtpbmcgdG8uXG4gICAgICAgIFsnbGVnYWN5JywgMF0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZTtcbiAgICAgICAgdGhpcy51cmwgPSAnaHR0cHM6Ly9zb2xhbmFtb2JpbGUuY29tL3dhbGxldHMnO1xuICAgICAgICB0aGlzLmljb24gPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCbWFXeHNQU0p1YjI1bElpQm9aV2xuYUhROUlqSTRJaUIzYVdSMGFEMGlNamdpSUhacFpYZENiM2c5SWkweklEQWdNamdnTWpnaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHY2dabWxzYkQwaUkwUkRRamhHUmlJK1BIQmhkR2dnWkQwaVRURTNMalFnTVRjdU5FZ3hOWFl5TGpSb01pNDBkaTB5TGpSYWJURXVNaTA1TGpab0xUSXVOSFl5TGpSb01pNDBWamN1T0ZvaUx6NDhjR0YwYUNCa1BTSk5NakV1TmlBelZqQm9MVEl1TkhZemFDMHpMalpXTUdndE1pNDBkak5vTFRJdU5IWTJMalpJTkM0MVlUSXVNU0F5TGpFZ01DQXhJREVnTUMwMExqSm9NaTQzVmpOSU5DNDFRVFF1TlNBMExqVWdNQ0F3SURBZ01DQTNMalZXTWpSb01qRXVObll0Tmk0MmFDMHlMalIyTkM0eVNESXVORll4TVM0MVl5NDFMak1nTVM0eUxqUWdNUzQ0TGpWb055NDFRVFl1TmlBMkxqWWdNQ0F3SURBZ01qUWdPVll6YUMweUxqUmFiVEFnTlM0M1lUUXVNaUEwTGpJZ01DQXhJREV0T0M0MElEQldOUzQwYURndU5IWXpMak5hSWk4K1BDOW5Qand2YzNablBnPT0nO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVyeSB0aW1lIHRoZSBjb25uZWN0aW9uIGlzIHJlY3ljbGVkIGluIHNvbWUgd2F5IChlZy4gYGRpc2Nvbm5lY3QoKWAgaXMgY2FsbGVkKVxuICAgICAgICAgKiBpbmNyZW1lbnQgdGhpcyBhbmQgdXNlIGl0IHRvIG1ha2Ugc3VyZSB0aGF0IGB0cmFuc2FjdGAgY2FsbHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgICogJ2dlbmVyYXRpb24nIGRvbid0IGNvbnRpbnVlIHRvIGRvIHdvcmsgYW5kIHRocm93IGV4Y2VwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBnZXRJc1N1cHBvcnRlZCQxKCkgPyBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlIDogV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZDtcbiAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlID0gY29uZmlnLmF1dGhvcml6YXRpb25SZXN1bHRDYWNoZTtcbiAgICAgICAgdGhpcy5fYWRkcmVzc1NlbGVjdG9yID0gY29uZmlnLmFkZHJlc3NTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5fYXBwSWRlbnRpdHkgPSBjb25maWcuYXBwSWRlbnRpdHk7XG4gICAgICAgIHRoaXMuX2NoYWluID0gKF9hID0gY29uZmlnLmNoYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbHVzdGVyVG9DaGFpbklkKGNvbmZpZy5jbHVzdGVyKTtcbiAgICAgICAgdGhpcy5faG9zdEF1dGhvcml0eSA9IGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5O1xuICAgICAgICB0aGlzLl9vbldhbGxldE5vdEZvdW5kID0gY29uZmlnLm9uV2FsbGV0Tm90Rm91bmQ7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCkudGhlbigoYXV0aG9yaXphdGlvblJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBhIHByaW9yIGF1dGhvcml6YXRpb24gcmVzdWx0IGlzLCByaWdodCBub3csIHRoZSBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRpb24gdGhhdCBhIG1vYmlsZSB3YWxsZXQgaXMgaW5zdGFsbGVkLiBUaGVyZSBpcyBubyBBUElcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSB0byB0ZXN0IGZvciB3aGV0aGVyIHRoZSBhc3NvY2lhdGlvbiBVUkkgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdWJsaWNLZXkgPT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyQxKHRoaXMuX3NlbGVjdGVkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRQdWJsaWNLZXlFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleSA/IHRoaXMuX3B1YmxpY0tleSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGluZztcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBkZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeVN0YXRlQ2hhbmdlJywgKHRoaXMuX3JlYWR5U3RhdGUgPSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bldpdGhHdWFyZChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBhdXRvQ29ubmVjdCgpYCBpbnN0ZWFkLiAqL1xuICAgIGF1dG9Db25uZWN0X0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5hdXRvQ29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXV0b0Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nIHx8IHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1BdXRob3JpemF0aW9uKHNpZ25JblBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgd2FsbGV0LmF1dGhvcml6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogdGhpcy5fY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduX2luX3BheWxvYWQ6IHNpZ25JblBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLnNldChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkaWRQdWJsaWNLZXlzQ2hhbmdlID0gXG4gICAgICAgICAgICAvLyBDYXNlIDE6IFdlIHN0YXJ0ZWQgZnJvbSBoYXZpbmcgbm8gYXV0aG9yaXphdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIC8vIENhc2UgMjogVGhlIG51bWJlciBvZiBhdXRob3JpemVkIGFjY291bnRzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50cy5sZW5ndGgpICE9PSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC8vIENhc2UgMzogVGhlIG5ldyBsaXN0IG9mIGFkZHJlc3NlcyBpc24ndCBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBvbGQgbGlzdCwgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5zb21lKChhY2NvdW50LCBpaSkgPT4gYWNjb3VudC5hZGRyZXNzICE9PSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzW2lpXS5hZGRyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgPSBhdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKTtcbiAgICAgICAgICAgIGlmIChkaWRQdWJsaWNLZXlzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlbGVjdGVkQWRkcmVzcyA9IHlpZWxkIHRoaXMuX2FkZHJlc3NTZWxlY3Rvci5zZWxlY3QoYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5tYXAoKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTZWxlY3RlZEFkZHJlc3MgIT09IHRoaXMuX3NlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgPSBuZXh0U2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHVibGljS2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIGp1c3Qgc2V0IGB0aGlzLl9zZWxlY3RlZEFkZHJlc3NgLCBgdGhpcy5wdWJsaWNLZXlgIGlzIGRlZmluaXRlbHkgbm9uLW51bGxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICBhdXRoX3Rva2VuOiBhdXRoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLl9hcHBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldERpc2Nvbm5lY3RlZEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuY2xlYXIoKTsgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbisrO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHVibGljS2V5O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhbnNhY3QoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0VXJpQmFzZSA9IChfYSA9IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YWxsZXRfdXJpX2Jhc2U7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB3YWxsZXRVcmlCYXNlID8geyBiYXNlVXJpOiB3YWxsZXRVcmlCYXNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVDb25maWcgPSB0aGlzLl9ob3N0QXV0aG9yaXR5ID8geyByZW1vdGVIb3N0QXV0aG9yaXR5OiB0aGlzLl9ob3N0QXV0aG9yaXR5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24gPSB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRyYW5zYWN0KGNhbGxiYWNrLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHJlbW90ZUNvbmZpZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gIT09IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pOyAvLyBOZXZlciByZXNvbHZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5jb2RlID09PSAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fb25XYWxsZXROb3RGb3VuZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydElzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0IHx8ICF0aGlzLl9zZWxlY3RlZEFkZHJlc3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdC5hdXRoX3Rva2VuLFxuICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5Db250ZXh0U2xvdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUYXJnZXRDb21taXRtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29ubmVjdGlvbi5jb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21taXRtZW50ID0gY29ubmVjdGlvbi5jb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50U2NvcmUgPSB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID09PSAnZmluYWxpemVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID09PSAnY29uZmlybWVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCcgPyAyIDogdGFyZ2V0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCcgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlIDwgdGFyZ2V0Q29tbWl0bWVudFNjb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2FwYWJpbGl0aWVzLCBfMSwgXzJdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFVubGlrZSB2ZXJzaW9uZWQgdHJhbnNhY3Rpb25zLCBsZWdhY3kgYFRyYW5zYWN0aW9uYCBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbWF5IG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgYGZlZVBheWVyYCBvciBgcmVjZW50QmxvY2toYXNoYC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGNvZGUgZXhpc3RzIHRvIHBhdGNoIHRoZW0gdXAgaW4gY2FzZSB0aGV5IGFyZSBtaXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgfHwgKHRyYW5zYWN0aW9uLmZlZVBheWVyID0gKF9hID0gdGhpcy5wdWJsaWNLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSB5aWVsZCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMuc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0geWllbGQgd2FsbGV0LnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB3YWxsZXQuc2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2VyaWFsaXplZFRyYW5zYWN0aW9uLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHByZWZsaWdodENvbW1pdG1lbnQ6IGdldFRhcmdldENvbW1pdG1lbnQoKSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZFRyYW5zYWN0aW9uXSA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMoW3RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgdGhpcy5wZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRNZXNzYWdlXSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW3NlbGVjdGVkQWRkcmVzc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHM6IFttZXNzYWdlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVkTWVzc2FnZS5zbGljZSgtU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduTWVzc2FnZUVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkluKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnB1dCksIHsgZG9tYWluOiAoX2EgPSBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQuZG9tYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaG9zdCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbiBpbiBmYWlsZWQsIG5vIHNpZ24gaW4gcmVzdWx0IHJldHVybmVkIGJ5IHdhbGxldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWNjb3VudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5maW5kKGFjYyA9PiBhY2MuYWRkcmVzcyA9PSBzaWduZWRJbkFkZHJlc3MpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBzaWduZWRJbkFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfSksIHsgcHVibGljS2V5OiB0b1VpbnQ4QXJyYXkoc2lnbmVkSW5BZGRyZXNzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHNpZ25lZEluQWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZE1lc3NhZ2U6IHRvVWludDhBcnJheShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25lZF9tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdG9VaW50OEFycmF5KGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBCbHVldG9vdGhIdG1sID0gYFxyXG4gICAgPGRpdiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50XCI+XHJcbiAgICA8YnV0dG9uIGlkPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlXCIgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2VcIj5cclxuICAgICAgICA8c3ZnIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiPlxyXG4gICAgICAgIDxwYXRoIGQ9XCJNMTQgMTIuNDYxIDguMyA2Ljc3Mmw1LjIzNC01LjIzM0wxMi4wMDYgMCA2Ljc3MiA1LjIzNCAxLjU0IDAgMCAxLjUzOWw1LjIzNCA1LjIzM0wwIDEyLjAwNmwxLjUzOSAxLjUyOEw2Ljc3MiA4LjNsNS42OSA1LjdMMTQgMTIuNDYxelwiIC8+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICA8L2J1dHRvbj5cclxuICAgIDxoMT48Yj5KdXBpdGVyPC9iPiB3YW50cyB0byBjb25uZWN0PC9oMT5cclxuICAgIDxwIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXN1YnRpdGxlXCI+Q29ubmVjdCB0byB5b3VyIG1vYmlsZSB3YWxsZXQgYXBwIHRocm91Z2ggQmx1ZXRvb3RoLjwvcD5cclxuICAgIDxkaXYgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29ubmVjdGlvbi1zdGF0dXMtY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGRpdiBpZD1cInN0YXR1cy1ub3QtY29ubmVjdGVkXCIgY2xhc3M9XCJjb25uZWN0aW9uLXN0YXR1c1wiPlxyXG4gICAgICAgIDxzdmcgY2xhc3M9XCJibHVldG9vdGgtaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNhMGEwYTBcIiBkPVwiTTE0LjI0IDEyLjAxbDIuMzIgMi4zMmMuMjgtLjcyLjQ0LTEuNTEuNDQtMi4zMyAwLS44Mi0uMTYtMS41OS0uNDMtMi4zMWwtMi4zMyAyLjMyem01LjI5LTUuM2wtMS4yNiAxLjI2Yy42MyAxLjIxLjk4IDIuNTcuOTggNC4wMnMtLjM2IDIuODItLjk4IDQuMDJsMS4yIDEuMmMuOTctMS41NCAxLjU0LTMuMzYgMS41NC01LjMxLS4wMS0xLjg5LS41NS0zLjY3LTEuNDgtNS4xOXptLTMuODIgMUwxMCAySDl2Ny41OUw0LjQxIDUgMyA2LjQxIDguNTkgMTIgMyAxNy41OSA0LjQxIDE5IDkgMTQuNDFWMjJoMWw1LjcxLTUuNzEtNC4zLTQuMjkgNC4zLTQuMjl6TTExIDUuODNsMS44OCAxLjg4TDExIDkuNTlWNS44M3ptMS44OCAxMC40NkwxMSAxOC4xN3YtMy43NmwxLjg4IDEuODh6XCIvPlxyXG4gICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDxwPk5vdCBjb25uZWN0ZWQ8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBpZD1cInN0YXR1cy1jb25uZWN0aW5nXCIgY2xhc3M9XCJjb25uZWN0aW9uLXN0YXR1c1wiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzcGlubmVyXCI+PC9kaXY+XHJcbiAgICAgICAgPHA+Q29ubmVjdGluZy4uLjwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwic3RhdHVzLWNvbm5lY3RlZFwiIGNsYXNzPVwiY29ubmVjdGlvbi1zdGF0dXNcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj5cclxuICAgICAgICA8c3ZnIGNsYXNzPVwiY2hlY2ttYXJrLWljb25cIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjNENBRjUwXCIgZD1cIk05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXpcIi8+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgPHA+Q29ubmVjdGVkPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uLWdyb3VwXCI+XHJcbiAgICAgICAgPGJ1dHRvbiBpZD1cImNhbmNlbC1idG5cIiBjbGFzcz1cImNhbmNlbC1idG5cIj5DYW5jZWw8L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIGlkPVwiY29ubmVjdC1idG5cIiBjbGFzcz1cImNvbm5lY3QtYnRuXCI+Q29ubmVjdDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuYDtcblxuY29uc3QgUVJDb2RlSHRtbCA9IGBcclxuPGRpdiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50XCI+XHJcbiAgPGJ1dHRvbiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZVwiIGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlXCI+XHJcbiAgICA8c3ZnIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiPlxyXG4gICAgICA8cGF0aCBkPVwiTTE0IDEyLjQ2MSA4LjMgNi43NzJsNS4yMzQtNS4yMzNMMTIuMDA2IDAgNi43NzIgNS4yMzQgMS41NCAwIDAgMS41MzlsNS4yMzQgNS4yMzNMMCAxMi4wMDZsMS41MzkgMS41MjhMNi43NzIgOC4zbDUuNjkgNS43TDE0IDEyLjQ2MXpcIiAvPlxyXG4gICAgPC9zdmc+XHJcbiAgPC9idXR0b24+XHJcbiAgPGgxPlNjYW4gdG8gY29ubmVjdDwvaDE+XHJcbiAgPHAgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtc3VidGl0bGVcIj5Vc2UgeW91ciB3YWxsZXQgYXBwIHRvIHNjYW4gdGhlIFFSIENvZGUgYW5kIGNvbm5lY3QuPC9wPlxyXG4gIDxkaXYgaWQ9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29kZS1jb250YWluZXJcIiAvPlxyXG48L2Rpdj5cclxuYDtcblxuY29uc3QgY3NzID0gYFxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7IC8qIFVzZSBmbGV4Ym94IHRvIGNlbnRlciBjb250ZW50ICovXHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IC8qIENlbnRlciBob3Jpem9udGFsbHkgKi9cclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IC8qIENlbnRlciB2ZXJ0aWNhbGx5ICovXHJcbiAgICBwb3NpdGlvbjogZml4ZWQ7IC8qIFN0YXkgaW4gcGxhY2UgKi9cclxuICAgIHotaW5kZXg6IDE7IC8qIFNpdCBvbiB0b3AgKi9cclxuICAgIGxlZnQ6IDA7XHJcbiAgICB0b3A6IDA7XHJcbiAgICB3aWR0aDogMTAwJTsgLyogRnVsbCB3aWR0aCAqL1xyXG4gICAgaGVpZ2h0OiAxMDAlOyAvKiBGdWxsIGhlaWdodCAqL1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwwLjQpOyAvKiBCbGFjayB3LyBvcGFjaXR5ICovXHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29udGVudCB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMTAxNDFmO1xyXG4gICAgcGFkZGluZzogMjBweDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICB3aWR0aDogODAlO1xyXG4gICAgbWF4LXdpZHRoOiA1MDBweDtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgLyogQ2VudGVyIGNoaWxkcmVuIGhvcml6b250YWxseSAqL1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXN1YnRpdGxlIHtcclxuICAgIGNvbG9yOiAjRDhEOEQ4O1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0b3A6IDE4cHg7XHJcbiAgICByaWdodDogMThweDtcclxuICAgIHBhZGRpbmc6IDEycHg7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMWExZjJlO1xyXG4gICAgYm9yZGVyOiBub25lO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG59XHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlOmZvY3VzLXZpc2libGUge1xyXG4gICAgb3V0bGluZS1jb2xvcjogd2hpdGU7XHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2Ugc3ZnIHtcclxuICAgIGZpbGw6ICM3Nzc7XHJcbiAgICB0cmFuc2l0aW9uOiBmaWxsIDIwMG1zIGVhc2UgMHM7XHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2U6aG92ZXIgc3ZnIHtcclxuICAgIGZpbGw6ICNmZmY7XHJcbn1cclxuXHJcbi5pY29uLWNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xyXG59XHJcblxyXG4uaWNvbiB7XHJcbiAgICB3aWR0aDogODBweDtcclxuICAgIGhlaWdodDogODBweDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7IC8qIFBsYWNlaG9sZGVyIGZvciBpY29uIGJhY2tncm91bmQgKi9cclxufVxyXG5cclxuLyogTW9kYWwgVGl0bGUgKi9cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50IGgxIHtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIGZvbnQtc2l6ZTogMjRweDsgICBcclxufVxyXG5cclxuLmJ1dHRvbi1ncm91cCB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBnYXA6IDEwcHg7XHJcbn1cclxuXHJcbi5jb25uZWN0LWJ0biwgLmNhbmNlbC1idG4ge1xyXG4gICAgZmxleDogMTtcclxuICAgIHBhZGRpbmc6IDEycHggMjBweDtcclxuICAgIGZvbnQtc2l6ZTogMTZweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xyXG59XHJcblxyXG4uY29ubmVjdC1idG4ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzAwN2JmZjtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIGJvcmRlcjogbm9uZTtcclxufVxyXG5cclxuLmNvbm5lY3QtYnRuOmhvdmVyIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDU2YjM7XHJcbn1cclxuXHJcbi5jYW5jZWwtYnRuIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG4gICAgY29sb3I6ICNhMGEwYTA7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYTBhMGEwO1xyXG59XHJcblxyXG4uY2FuY2VsLWJ0bjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE2MCwgMTYwLCAxNjAsIDAuMSk7XHJcbn1cclxuXHJcbi8qIEJUIENvbm5lY3Rpb24gU3RhdHVzICovXHJcblxyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbm5lY3Rpb24tc3RhdHVzLWNvbnRhaW5lciB7XHJcbiAgICBtYXJnaW46IDIwcHggMHB4IDIwcHggMHB4O1xyXG59XHJcblxyXG4uY29ubmVjdGlvbi1zdGF0dXMge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBtYXJnaW46IDIwcHggMDtcclxufVxyXG4gIFxyXG4uY29ubmVjdGlvbi1zdGF0dXMgcCB7XHJcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xyXG4gICAgY29sb3I6ICNhMGEwYTA7XHJcbn1cclxuICBcclxuLmJsdWV0b290aC1pY29uLCAuY2hlY2ttYXJrLWljb24ge1xyXG4gICAgd2lkdGg6IDQ4cHg7XHJcbiAgICBoZWlnaHQ6IDQ4cHg7XHJcbn1cclxuICBcclxuLnNwaW5uZXIge1xyXG4gICAgYm9yZGVyOiA0cHggc29saWQgI2YzZjNmMztcclxuICAgIGJvcmRlci10b3A6IDRweCBzb2xpZCAjMzQ5OGRiO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgd2lkdGg6IDQwcHg7XHJcbiAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xyXG59XHJcbiAgXHJcbkBrZXlmcmFtZXMgc3BpbiB7XHJcbiAgICAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XHJcbiAgICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxyXG59XHJcblxyXG4vKiBRUiBDb2RlICovXHJcblxyXG4jbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLXFyLWNvZGUtY29udGFpbmVyIHtcclxuICAgIHdpZHRoOiA1MDBweDtcclxuICAgIGhlaWdodDogNTAwcHg7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbn1cclxuYDtcblxuY2xhc3MgRW1iZWRkZWRNb2RhbCB7XG4gICAgY29uc3RydWN0b3IodGl0bGUpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGU7XG4gICAgICAgIC8vIEJpbmQgbWV0aG9kcyB0byBlbnN1cmUgYHRoaXNgIGNvbnRleHQgaXMgY29ycmVjdFxuICAgICAgICB0aGlzLmluaXQgPSB0aGlzLmluaXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbmplY3RRUkNvZGVIVE1MID0gdGhpcy5pbmplY3RRUkNvZGVIVE1MLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaW5qZWN0Qmx1ZXRvb3RoSFRNTCA9IHRoaXMuaW5qZWN0Qmx1ZXRvb3RoSFRNTC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW4gPSB0aGlzLm9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ID0gdGhpcy5jb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknKTtcbiAgICB9XG4gICAgaW5pdChxckNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbmplY3RpbmcgbW9kYWwnKTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLmluamVjdFFSQ29kZUhUTUwocXJDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb25TdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RhdHVzZXMgPSBbJ25vdC1jb25uZWN0ZWQnLCAnY29ubmVjdGluZycsICdjb25uZWN0ZWQnXTtcbiAgICAgICAgc3RhdHVzZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLl9yb290LnF1ZXJ5U2VsZWN0b3IoYCNzdGF0dXMtJHtzfWApO1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gcyA9PT0gc3RhdHVzID8gJ2ZsZXgnIDogJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5qZWN0U3R5bGVzKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3R5bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluamVjdGVkXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLXN0eWxlcycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LmlkID0gJ21vYmlsZS13YWxsZXQtYWRhcHRlci1zdHlsZXMnO1xuICAgICAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjc3M7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgcG9wdWxhdGVRUkNvZGUocXJVcmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHFyY29kZUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29kZS1jb250YWluZXInKTtcbiAgICAgICAgICAgIGlmIChxcmNvZGVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxckNvZGVFbGVtZW50ID0geWllbGQgUVJDb2RlLnRvQ2FudmFzKHFyVXJsLCB7IHdpZHRoOiA0MDAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHFyY29kZUNvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxcmNvZGVDb250YWluZXIucmVwbGFjZUNoaWxkKHFyQ29kZUVsZW1lbnQsIHFyY29kZUNvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcXJjb2RlQ29udGFpbmVyLmFwcGVuZENoaWxkKHFyQ29kZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUVJDb2RlIENvbnRhaW5lciBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluamVjdFFSQ29kZUhUTUwocXJDb2RlKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBIVE1MIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWRcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpO1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZVFSQ29kZShxckNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIG1vZGFsXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcm9vdC5pZCA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aSc7XG4gICAgICAgIHRoaXMuX3Jvb3QuY2xhc3NOYW1lID0gJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbCc7XG4gICAgICAgIHRoaXMuX3Jvb3QuaW5uZXJIVE1MID0gUVJDb2RlSHRtbDtcbiAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAvLyBBcHBlbmQgdGhlIG1vZGFsIHRvIHRoZSBib2R5XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdCk7XG4gICAgICAgIC8vIFJlbmRlciB0aGUgUVJDb2RlXG4gICAgICAgIHRoaXMucG9wdWxhdGVRUkNvZGUocXJDb2RlKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICBpbmplY3RCbHVldG9vdGhIVE1MKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgSFRNTCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLXJvb3QtdWknKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcm9vdC5pZCA9ICdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aSc7XG4gICAgICAgIHRoaXMuX3Jvb3QuY2xhc3NOYW1lID0gJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbCc7XG4gICAgICAgIHRoaXMuX3Jvb3QuaW5uZXJIVE1MID0gQmx1ZXRvb3RoSHRtbDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9yb290KTtcbiAgICAgICAgdGhpcy5hdHRhY2hFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICBhdHRhY2hFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjbG9zZUJ0biA9IHRoaXMuX3Jvb3QucXVlcnlTZWxlY3RvcignI21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZScpO1xuICAgICAgICBjb25zdCBjYW5jZWxCdG4gPSB0aGlzLl9yb290LnF1ZXJ5U2VsZWN0b3IoJyNjYW5jZWwtYnRuJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RCdG4gPSB0aGlzLl9yb290LnF1ZXJ5U2VsZWN0b3IoJyNjb25uZWN0LWJ0bicpO1xuICAgICAgICBjbG9zZUJ0biA9PT0gbnVsbCB8fCBjbG9zZUJ0biA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuICAgICAgICBjYW5jZWxCdG4gPT09IG51bGwgfHwgY2FuY2VsQnRuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuICAgICAgICBjb25uZWN0QnRuID09PSBudWxsIHx8IGNvbm5lY3RCdG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3RCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNvbm5lY3QoKSk7XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ01vZGFsIG9wZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Quc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnbm90LWNvbm5lY3RlZCcpOyAvLyBSZXNldCBzdGF0dXMgd2hlbiBvcGVuaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ01vZGFsIGNsb3NlJyk7XG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ25vdC1jb25uZWN0ZWQnKTsgLy8gUmVzZXQgc3RhdHVzIHdoZW4gY2xvc2luZ1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW5nLi4uJyk7XG4gICAgICAgIC8vIE1vY2sgY29ubmVjdGlvblxuICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiBwcm9jZXNzXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQhJyk7XG4gICAgICAgIH0sIDUwMDApOyAvLyA1IHNlY29uZHMgZGVsYXlcbiAgICB9XG59XG5cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGVXYWxsZXROYW1lID0gJ01XQSAoUmVtb3RlKSc7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZUFycmF5ID0gdG9VaW50OEFycmF5JDEoYWRkcmVzcyk7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZUFycmF5KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBtb2JpbGUgb3BlcmF0aW5nIHN5c3RlbS5cbiAqIFJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIG9uIGEgbW9iaWxlIG9wZXJhdGluZyBzeXN0ZW0sIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2JpbGVPcGVyYXRpbmdTeXN0ZW0oKSB7XG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgLy8gV2luZG93cyBQaG9uZSBtdXN0IGNvbWUgZmlyc3QgYmVjYXVzZSBpdHMgVUEgYWxzbyBjb250YWlucyBcIkFuZHJvaWRcIlxuICAgIGlmICgvd2luZG93cyBwaG9uZS9pLnRlc3QodXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKC9hbmRyb2lkL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBpT1MgZGV0ZWN0aW9uIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzkwMzk4ODUvMTc3NzEwXG4gICAgaWYgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0SXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ICYmXG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIWlzTW9iaWxlT3BlcmF0aW5nU3lzdGVtKCkpO1xufVxuLyoqXG4gKiBUaGlzIGJ1cm5lciB3YWxsZXQgYWRhcHRlciBpcyB1bnNhZmUgdG8gdXNlIGFuZCBpcyBvbmx5IGluY2x1ZGVkIHRvIHByb3ZpZGUgYW4gZWFzeSB3YXkgZm9yIGFwcGxpY2F0aW9ucyB0byB0ZXN0XG4gKiBXYWxsZXQgQWRhcHRlciB3aXRob3V0IHVzaW5nIGEgdGhpcmQtcGFydHkgd2FsbGV0LlxuICovXG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlIGV4dGVuZHMgQmFzZVNpZ25Jbk1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zID0gbmV3IFNldChcbiAgICAgICAgLy8gRklYTUUoIzI0NCk6IFdlIGNhbid0IGFjdHVhbGx5IGtub3cgd2hhdCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkIHVudGlsIHdlIGtub3cgd2hpY2ggd2FsbGV0IHdlJ3JlIHRhbGtpbmcgdG8uXG4gICAgICAgIFsnbGVnYWN5JywgMF0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZTtcbiAgICAgICAgdGhpcy51cmwgPSAnaHR0cHM6Ly9zb2xhbmFtb2JpbGUuY29tL3dhbGxldHMnO1xuICAgICAgICB0aGlzLmljb24gPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCbWFXeHNQU0p1YjI1bElpQm9aV2xuYUhROUlqSTRJaUIzYVdSMGFEMGlNamdpSUhacFpYZENiM2c5SWkweklEQWdNamdnTWpnaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHY2dabWxzYkQwaUkwUkRRamhHUmlJK1BIQmhkR2dnWkQwaVRURTNMalFnTVRjdU5FZ3hOWFl5TGpSb01pNDBkaTB5TGpSYWJURXVNaTA1TGpab0xUSXVOSFl5TGpSb01pNDBWamN1T0ZvaUx6NDhjR0YwYUNCa1BTSk5NakV1TmlBelZqQm9MVEl1TkhZemFDMHpMalpXTUdndE1pNDBkak5vTFRJdU5IWTJMalpJTkM0MVlUSXVNU0F5TGpFZ01DQXhJREVnTUMwMExqSm9NaTQzVmpOSU5DNDFRVFF1TlNBMExqVWdNQ0F3SURBZ01DQTNMalZXTWpSb01qRXVObll0Tmk0MmFDMHlMalIyTkM0eVNESXVORll4TVM0MVl5NDFMak1nTVM0eUxqUWdNUzQ0TGpWb055NDFRVFl1TmlBMkxqWWdNQ0F3SURBZ01qUWdPVll6YUMweUxqUmFiVEFnTlM0M1lUUXVNaUEwTGpJZ01DQXhJREV0T0M0MElEQldOUzQwYURndU5IWXpMak5hSWk4K1BDOW5Qand2YzNablBnPT0nO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVyeSB0aW1lIHRoZSBjb25uZWN0aW9uIGlzIHJlY3ljbGVkIGluIHNvbWUgd2F5IChlZy4gYGRpc2Nvbm5lY3QoKWAgaXMgY2FsbGVkKVxuICAgICAgICAgKiBpbmNyZW1lbnQgdGhpcyBhbmQgdXNlIGl0IHRvIG1ha2Ugc3VyZSB0aGF0IGB0cmFuc2FjdGAgY2FsbHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgICogJ2dlbmVyYXRpb24nIGRvbid0IGNvbnRpbnVlIHRvIGRvIHdvcmsgYW5kIHRocm93IGV4Y2VwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBnZXRJc1N1cHBvcnRlZCgpID8gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSA6IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQ7XG4gICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZSA9IGNvbmZpZy5hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGU7XG4gICAgICAgIHRoaXMuX2FkZHJlc3NTZWxlY3RvciA9IGNvbmZpZy5hZGRyZXNzU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX2FwcElkZW50aXR5ID0gY29uZmlnLmFwcElkZW50aXR5O1xuICAgICAgICB0aGlzLl9jaGFpbiA9IGNvbmZpZy5jaGFpbjtcbiAgICAgICAgdGhpcy5faG9zdEF1dGhvcml0eSA9IGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5O1xuICAgICAgICB0aGlzLl9vbldhbGxldE5vdEZvdW5kID0gY29uZmlnLm9uV2FsbGV0Tm90Rm91bmQ7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCkudGhlbigoYXV0aG9yaXphdGlvblJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBhIHByaW9yIGF1dGhvcml6YXRpb24gcmVzdWx0IGlzLCByaWdodCBub3csIHRoZSBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRpb24gdGhhdCBhIG1vYmlsZSB3YWxsZXQgaXMgaW5zdGFsbGVkLiBUaGVyZSBpcyBubyBBUElcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSB0byB0ZXN0IGZvciB3aGV0aGVyIHRoZSBhc3NvY2lhdGlvbiBVUkkgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdWJsaWNLZXkgPT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyh0aGlzLl9zZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXkgPyB0aGlzLl9wdWJsaWNLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpbmc7XG4gICAgfVxuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHlTdGF0ZUNoYW5nZScsICh0aGlzLl9yZWFkeVN0YXRlID0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5XaXRoR3VhcmQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXV0b0Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nIHx8IHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1BdXRob3JpemF0aW9uKHNpZ25JblBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhbGxldClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IHRoaXMuX2NoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbl9pbl9wYXlsb2FkOiBzaWduSW5QYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGlkUHVibGljS2V5c0NoYW5nZSA9IFxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBXZSBzdGFydGVkIGZyb20gaGF2aW5nIG5vIGF1dGhvcml6YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IFRoZSBudW1iZXIgb2YgYXV0aG9yaXplZCBhY2NvdW50cyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHMubGVuZ3RoKSAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDM6IFRoZSBuZXcgbGlzdCBvZiBhZGRyZXNzZXMgaXNuJ3QgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkIGxpc3QsIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuc29tZSgoYWNjb3VudCwgaWkpID0+IGFjY291bnQuYWRkcmVzcyAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50c1tpaV0uYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID0gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICBpZiAoZGlkUHVibGljS2V5c0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZWxlY3RlZEFkZHJlc3MgPSB5aWVsZCB0aGlzLl9hZGRyZXNzU2VsZWN0b3Iuc2VsZWN0KGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0ZWRBZGRyZXNzICE9PSB0aGlzLl9zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzID0gbmV4dFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBqdXN0IHNldCBgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzYCwgYHRoaXMucHVibGljS2V5YCBpcyBkZWZpbml0ZWx5IG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aF90b2tlbjogYXV0aFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IHdoeSB0aGlzIGNhbGwgdGhyb3dzIFwiVHlwZUVycm9yOiBfYS50ZXJtaW5hdGVTZXNzaW9uIGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgICAgICAgICAgIC8vICBldmVuIHRob3VnaCB0aGUgc2Vzc2lvbiB0ZXJtaW5hdGlvbiBpcyBhY3R1YWxseSBleGVjdXRlZCAod2Vic29ja2V0IGNsb3NlcykuIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl93YWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXJtaW5hdGVTZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuY2xlYXIoKTsgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbisrO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHVibGljS2V5O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YWxsZXQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zYWN0KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldFVyaUJhc2UgPSAoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FsbGV0X3VyaV9iYXNlO1xuICAgICAgICAgICAgY29uc3QgYmFzZUNvbmZpZyA9IHdhbGxldFVyaUJhc2UgPyB7IGJhc2VVcmk6IHdhbGxldFVyaUJhc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZUNvbmZpZyksIHsgcmVtb3RlSG9zdEF1dGhvcml0eTogdGhpcy5faG9zdEF1dGhvcml0eSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgbW9kYWwgPSBuZXcgRW1iZWRkZWRNb2RhbCgnTVdBIFFSJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX3dhbGxldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXNzb2NpYXRpb25VcmwsIHJlc3VsdDogcHJvbWlzZSB9ID0geWllbGQgdHJhbnNhY3RSZW1vdGUoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBjYWxsYmFjayh3YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pLCByZW1vdGVDb25maWcpO1xuICAgICAgICAgICAgICAgIG1vZGFsLmluaXQoYXNzb2NpYXRpb25VcmwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbiAhPT0gY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKCgpID0+IHsgfSk7IC8vIE5ldmVyIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5uYW1lID09PSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBlLmNvZGUgPT09ICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9vbldhbGxldE5vdEZvdW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0SXNBdXRob3JpemVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgfHwgIXRoaXMuX3NlbGVjdGVkQWRkcmVzcylcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0LmF1dGhfdG9rZW4sXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IHRoaXMuX3NlbGVjdGVkQWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSB5aWVsZCB3YWxsZXQuc2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkNvbnRleHRTbG90ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbkNvbnRleHRTbG90O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRhcmdldENvbW1pdG1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25uZWN0aW9uLmNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbW1pdG1lbnQgPSBjb25uZWN0aW9uLmNvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA9IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDb21taXRtZW50U2NvcmUgPSB0YXJnZXRDb21taXRtZW50ID09PSAnZmluYWxpemVkJyA/IDIgOiB0YXJnZXRDb21taXRtZW50ID09PSAnY29uZmlybWVkJyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmbGlnaHRDb21taXRtZW50U2NvcmUgPCB0YXJnZXRDb21taXRtZW50U2NvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjYXBhYmlsaXRpZXMsIF8xLCBfMl0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmdldENhcGFiaWxpdGllcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiQxKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBVbmxpa2UgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucywgbGVnYWN5IGBUcmFuc2FjdGlvbmAgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1heSBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGBmZWVQYXllcmAgb3IgYHJlY2VudEJsb2NraGFzaGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjb2RlIGV4aXN0cyB0byBwYXRjaCB0aGVtIHVwIGluIGNhc2UgdGhleSBhcmUgbWlzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8ICh0cmFuc2FjdGlvbi5mZWVQYXllciA9IChfYSA9IHRoaXMucHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0geWllbGQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24kMShzaWduZWRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2VyaWFsaXplZFRyYW5zYWN0aW9uLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHByZWZsaWdodENvbW1pdG1lbnQ6IGdldFRhcmdldENvbW1pdG1lbnQoKSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZFRyYW5zYWN0aW9uXSA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnMoW3RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgdGhpcy5wZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRNZXNzYWdlXSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW3NlbGVjdGVkQWRkcmVzc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHM6IFttZXNzYWdlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVkTWVzc2FnZS5zbGljZSgtU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25JbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm1BdXRob3JpemF0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQpLCB7IGRvbWFpbjogKF9hID0gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LmRvbWFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhvc3QgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ24gaW4gZmFpbGVkLCBubyBzaWduIGluIHJlc3VsdCByZXR1cm5lZCBieSB3YWxsZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BZGRyZXNzID0gYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFjY291bnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYiA9IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuZmluZChhY2MgPT4gYWNjLmFkZHJlc3MgPT0gc2lnbmVkSW5BZGRyZXNzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogc2lnbmVkSW5BZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIH0pLCB7IHB1YmxpY0tleTogdG9VaW50OEFycmF5JDEoc2lnbmVkSW5BZGRyZXNzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHNpZ25lZEluQWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZE1lc3NhZ2U6IHRvVWludDhBcnJheSQxKGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmVkX21lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkkMShhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3QoYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBDQUNIRV9LRVkgPSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckRlZmF1bHRBdXRob3JpemF0aW9uQ2FjaGUnO1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSgpIHtcbiAgICBsZXQgc3RvcmFnZTtcbiAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIGNhdGNoIChfYSkgeyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShDQUNIRV9LRVkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0b3JhZ2UuZ2V0SXRlbShDQUNIRV9LRVkpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShDQUNIRV9LRVksIEpTT04uc3RyaW5naWZ5KGF1dGhvcml6YXRpb25SZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyKG1vYmlsZVdhbGxldEFkYXB0ZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24obW9iaWxlV2FsbGV0QWRhcHRlci51cmwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyKCkge1xuICAgIHJldHVybiBkZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyO1xufVxuXG5leHBvcnQgeyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUsIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIgfTtcbiJdLCJuYW1lcyI6WyJCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiLCJXYWxsZXRSZWFkeVN0YXRlIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0Q29ubmVjdGlvbkVycm9yIiwiV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24kMSIsIlB1YmxpY0tleSIsInRyYW5zYWN0IiwidHJhbnNhY3RSZW1vdGUiLCJRUkNvZGUiLCJ0b1VpbnQ4QXJyYXkiLCJ0b1VpbnQ4QXJyYXkkMSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImJhc2U2NEVuY29kZWRCeXRlQXJyYXkiLCJVaW50OEFycmF5Iiwid2luZG93IiwiYXRvYiIsInNwbGl0IiwibWFwIiwiYyIsImNoYXJDb2RlQXQiLCJnZXRJc1N1cHBvcnRlZCQxIiwiaXNTZWN1cmVDb250ZXh0IiwiZG9jdW1lbnQiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUiLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTJDEiLCJnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyQxIiwiYWRkcmVzcyIsInB1YmxpY0tleUJ5dGVBcnJheSIsInRyYW5zYWN0aW9uIiwiY2x1c3RlclRvQ2hhaW5JZCIsImNsdXN0ZXIiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJfYSIsInN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMiLCJTZXQiLCJuYW1lIiwidXJsIiwiaWNvbiIsIl9jb25uZWN0aW5nIiwiX2Nvbm5lY3Rpb25HZW5lcmF0aW9uIiwiX3JlYWR5U3RhdGUiLCJMb2FkYWJsZSIsIlVuc3VwcG9ydGVkIiwiX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsImF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSIsIl9hZGRyZXNzU2VsZWN0b3IiLCJhZGRyZXNzU2VsZWN0b3IiLCJfYXBwSWRlbnRpdHkiLCJhcHBJZGVudGl0eSIsIl9jaGFpbiIsImNoYWluIiwiX2hvc3RBdXRob3JpdHkiLCJyZW1vdGVIb3N0QXV0aG9yaXR5IiwiX29uV2FsbGV0Tm90Rm91bmQiLCJvbldhbGxldE5vdEZvdW5kIiwiZ2V0IiwiYXV0aG9yaXphdGlvblJlc3VsdCIsImRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCIsInB1YmxpY0tleSIsIl9wdWJsaWNLZXkiLCJfc2VsZWN0ZWRBZGRyZXNzIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29ubmVjdGVkIiwiX2F1dGhvcml6YXRpb25SZXN1bHQiLCJjb25uZWN0aW5nIiwicmVhZHlTdGF0ZSIsIkluc3RhbGxlZCIsImVtaXQiLCJydW5XaXRoR3VhcmQiLCJjYWxsYmFjayIsImF1dG9Db25uZWN0X0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJhdXRvQ29ubmVjdCIsImNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQiLCJoYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0IiwiY29ubmVjdCIsInBlcmZvcm1BdXRob3JpemF0aW9uIiwic2lnbkluUGF5bG9hZCIsIndhbGxldCIsImF1dGhvcml6ZSIsImlkZW50aXR5Iiwic2lnbl9pbl9wYXlsb2FkIiwiYWxsIiwic2V0IiwiZGlkUHVibGljS2V5c0NoYW5nZSIsImFjY291bnRzIiwibGVuZ3RoIiwic29tZSIsImFjY291bnQiLCJpaSIsIm5leHRTZWxlY3RlZEFkZHJlc3MiLCJzZWxlY3QiLCJwZXJmb3JtUmVhdXRob3JpemF0aW9uIiwiYXV0aFRva2VuIiwiYXV0aF90b2tlbiIsImRpc2Nvbm5lY3QiLCJjbGVhciIsIndhbGxldFVyaUJhc2UiLCJ3YWxsZXRfdXJpX2Jhc2UiLCJiYXNlVXJpIiwidW5kZWZpbmVkIiwicmVtb3RlQ29uZmlnIiwiY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwiY29kZSIsImFzc2VydElzQXV0aG9yaXplZCIsInNlbGVjdGVkQWRkcmVzcyIsInBlcmZvcm1TaWduVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwic2lnbmVkVHJhbnNhY3Rpb25zIiwic2lnblRyYW5zYWN0aW9ucyIsImVycm9yIiwic2VuZFRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJtaW5Db250ZXh0U2xvdCIsImdldFRhcmdldENvbW1pdG1lbnQiLCJ0YXJnZXRDb21taXRtZW50IiwiY29tbWl0bWVudCIsInRhcmdldFByZWZsaWdodENvbW1pdG1lbnQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwicHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlIiwidGFyZ2V0Q29tbWl0bWVudFNjb3JlIiwiY2FwYWJpbGl0aWVzIiwiXzEiLCJfMiIsImdldENhcGFiaWxpdGllcyIsImZlZVBheWVyIiwicmVjZW50QmxvY2toYXNoIiwiYmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwic3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnMiLCJzaWduYXR1cmVzIiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMiLCJzaWduZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJzaWduTWVzc2FnZSIsInNpZ25lZE1lc3NhZ2UiLCJzaWduTWVzc2FnZXMiLCJhZGRyZXNzZXMiLCJwYXlsb2FkcyIsInNpZ25hdHVyZSIsInNsaWNlIiwic2lnbkluIiwiaW5wdXQiLCJfYiIsImRvbWFpbiIsImxvY2F0aW9uIiwiaG9zdCIsInNpZ25faW5fcmVzdWx0Iiwic2lnbmVkSW5BZGRyZXNzIiwic2lnbmVkSW5BY2NvdW50IiwiZmluZCIsImFjYyIsInNpZ25lZF9tZXNzYWdlIiwiQmx1ZXRvb3RoSHRtbCIsIlFSQ29kZUh0bWwiLCJjc3MiLCJFbWJlZGRlZE1vZGFsIiwidGl0bGUiLCJfcm9vdCIsIl90aXRsZSIsImluaXQiLCJiaW5kIiwiaW5qZWN0UVJDb2RlSFRNTCIsImluamVjdEJsdWV0b290aEhUTUwiLCJvcGVuIiwiY2xvc2UiLCJnZXRFbGVtZW50QnlJZCIsInFyQ29kZSIsImNvbnNvbGUiLCJsb2ciLCJpbmplY3RTdHlsZXMiLCJzZXRDb25uZWN0aW9uU3RhdHVzIiwic3RhdHVzIiwic3RhdHVzZXMiLCJmb3JFYWNoIiwicyIsImVsIiwicXVlcnlTZWxlY3RvciIsIkhUTUxFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5Iiwic3R5bGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwb3B1bGF0ZVFSQ29kZSIsInFyVXJsIiwicXJjb2RlQ29udGFpbmVyIiwicXJDb2RlRWxlbWVudCIsInRvQ2FudmFzIiwid2lkdGgiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInJlcGxhY2VDaGlsZCIsImNsYXNzTmFtZSIsImlubmVySFRNTCIsImJvZHkiLCJhdHRhY2hFdmVudExpc3RlbmVycyIsImNsb3NlQnRuIiwiY2FuY2VsQnRuIiwiY29ubmVjdEJ0biIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZWJ1ZyIsInNldFRpbWVvdXQiLCJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUmVtb3RlV2FsbGV0TmFtZSIsIlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMiLCJnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyIsImlzTW9iaWxlT3BlcmF0aW5nU3lzdGVtIiwiTVNTdHJlYW0iLCJnZXRJc1N1cHBvcnRlZCIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGUiLCJfd2FsbGV0IiwidGVybWluYXRlU2Vzc2lvbiIsImJhc2VDb25maWciLCJtb2RhbCIsImFzc29jaWF0aW9uVXJsIiwicHJvbWlzZSIsInRvU3RyaW5nIiwiY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvciIsIkNBQ0hFX0tFWSIsImNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJzdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsIkpTT04iLCJwYXJzZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlciIsIm1vYmlsZVdhbGxldEFkYXB0ZXIiLCJjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n");

/***/ })

};
;